1. #### 算法分析题	![](/home/dawn/qqDocuments/夸克分享_1679200241360_0.jpg)

​	![](/home/dawn/qqDocuments/夸克分享_1679200285432_0.jpg)

#### 2.算法实现题

**3_13**

1. 代码

    ```c++
    # include <iostream>
    # include <fstream>
    # include <unistd.h>
    # include <vector>
    # include <string>
    using namespace std;
    
    /*
    问题描述：长为n的一个数num 将其分为k段 求这k段的最大乘积
    1. dp数组的含义
    dp[i][j]表示 将num的前i + 1位数字组成的子数字sub_num分成j段，这j段的最大乘积
    2. 状态转移
    dp[i][j]可以从 dp[i - 1][j - 1], dp[i - 2][j - 1], ... , dp[j - 1][j - 1]转移而来
    3. dp数组的初始化
    整个dp数组可以先初始化为0(考虑到dp数组中 其实当i < j时 dp[i][j]是不存在的，因此赋为0更好些)
    显然dp[i][1] = num的前i + 1位数字组成的子数字sub_num
    4. dp数组的遍历顺序
    可以从状态转移方程中看到 dp[i][j] 依赖于 dp[i - 1][k](i - 1 <= k < j), 
    我们的遍历顺序只需要保证 在计算dp[i][j]时 它左上角的元素都是已经计算过的 
    因此可以是 先在外层循环中正向遍历i 再在内层循环中正向遍历j
    也可以是 先在外层循环中正向遍历j 再在内层循环中正向遍历i
    5. dp数组的验证
    略
    */
    
    // sub_num用来获取 从第begin位开始 长为len的子数字
    int sub_num(int num, int begin, int len) {
        return stoi(to_string(num).substr(begin, len));
    }
    
    int main() {
        int n, k, num;
        string path = get_current_dir_name();
        // cout << path << endl;
        ifstream in(path + "/cpp/course/algorithm_analyse/3_13_input.txt", ios::in);
        ofstream out(path + "/cpp/course/algorithm_analyse/3_13_output.txt", ios::out);
        
        while (!in.eof()) {
            in >> n >> k >> num;
    
            vector<vector<int>> dp(n, vector<int>(k + 1, 0));
            for (int i = 0; i < n; ++i) dp[i][1] = sub_num(num, 0, i + 1);
    
            for (int i = 1; i < n; ++i) {
                for (int j = 2; j <= k; ++j) {
                    for (int l = j - 1; l <= i - 1; ++l) {
                        dp[i][j] = max(dp[i][j], dp[l][j - 1] * sub_num(num, l, i - l));
                    }
                }
            }
    
            out << dp[n - 1][k] << endl;
        }
    
        return 0;
    }
    ```

2. 输入输出

    1. 输入：每两行为一组测试用例 其中第一行是 数字的长度 和 划分的段数  第二行是数字

        ```markdown
        2 1
        15
        4 3
        1589
        6 3
        114514
        7 4
        1919810
        10 3
        9876543210
        ```

    2. 输出: 每一行为一组输出 

        ```markdown
        15
        600
        23256
        1260441
        1328855592
        ```

        

**3_17**

1. 代码

    ```c++
    # include <iostream>
    # include <fstream>
    # include <vector>
    # include <string>
    # include <unistd.h>
    using namespace std;
    
    /*
    1. dp数组的含义
    dp[i][j] 是指A前i个字符组成的子串sub_a 与 B前j个字符组成的子串sub_b的扩展距离
    2. 状态转移
    dp[i][j] 可以由 dp[i - 1][j] dp[i][j - 1] dp[i - 1][j - 1]转移得到
    3. dp数组的初始化
    因为求得是最小值，因此数组初始化时均设置为一个较大的数 
    dp[0][j]初始化为 k * j, dp[i][0]初始化为 k * i
    4. 遍历顺序
    根据状态转移方程，先正向遍历i，再正向遍历j 或者 先正向遍历j，再正向遍历i 均可
    5. 验证dp数组
    略
    */
    
    int main() {
        string A, B;
        int k;
        string path = get_current_dir_name();
        ifstream in(path + "/cpp/course/algorithm_analyse/3_17_input.txt", ios::in);
        ofstream out(path + "/cpp/course/algorithm_analyse/3_17_output.txt", ios::out | ios::trunc);
        in >> A >> B >> k;
    
        int al = A.size(), bl = B.size();
        vector<vector<int>> dp(al + 1, vector<int> (bl + 1, 0x3f3f3f3f));
        for (int i = 0; i <= al; ++i) dp[i][0] = i * k;
        for (int i = 0; i <= bl; ++i) dp[0][i] = i * k;
    
        for (int i = 1; i <= al; ++i) {
            for (int j = 1; j <= bl; ++j) {
                dp[i][j] = min(dp[i][j], min(dp[i - 1][j] + k, min(dp[i][j - 1] + k, dp[i - 1][j - 1] + abs(A[i - 1] - B[j - 1]))));
            }
        }
    
        out << dp[al][bl];
    
        return 0;
    }
    ```

2. 输入输出

    1. 输入:  每三行为一组测试用例，其中第一行是字符串A，第二行是字符串B，第三行是k

        ```markdown
        cmc
        snmn
        2
        abc
        azbc
        2
        faajakf
        glakjfalsf
        4
        fjalsdjf
        fjastrrqe
        2
        abcdef
        abcdef
        99
        ```

    2. 输出：每一行是一组输出

        ```markdown
        10
        2
        22
        15
        0
        ```

        
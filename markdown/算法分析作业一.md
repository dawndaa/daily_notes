![](/media/dawn/Ventoy/Study/大二/算法分析与设计/夸克分享_1678681650564_0.jpg)



2_2

代码：

```c++
# include <fstream>
# include <vector>
# include <utility>
# include <unistd.h>
# include <string>
using namespace std;

/*
All the situations are consist of the following situations:
m: 6 6 8 8 8  10 10 10 12 
n: 6 8 6 8 10 8  10 12 10 
*/

struct pt {
    int x;
    int y;
};

class Horse {
public:
    Horse(int r, int c);
    ~Horse() {};
    void print(int m, int n, ofstream& out);
    bool partition(int, int, int, int);

private:
    pt *g66, *g68, *g86, *g88, *g810, *g108, *g1010, *g1012, *g1210;
    pt loop[20][20];
    int r, c;
    void get_step(int, int, const vector<vector<int>>&, pt*);
    void base(int, int, int, int);
    void build(int, int, int, int, int, pt*);
    int get_pos(int, int, int);
};

Horse::Horse(int rr, int cc) {
    cout << "Horse" << endl;
    vector<vector<int>> arr(20, vector<int> (20));
    r = rr, c = cc;

    ifstream in_0("./cpp/course/algorithm_analyse/66.txt", ios::in);
    ifstream in_1("./cpp/course/algorithm_analyse/68.txt", ios::in);
    ifstream in_2("./cpp/course/algorithm_analyse/88.txt", ios::in);
    ifstream in_3("./cpp/course/algorithm_analyse/810.txt", ios::in);
    ifstream in_4("./cpp/course/algorithm_analyse/1010.txt", ios::in);
    ifstream in_5("./cpp/course/algorithm_analyse/1012.txt", ios::in);

    g66 = new pt[36], g68 = new pt[48], g86 = new pt[48];
    g88 = new pt[64], g810 = new pt[80], g108 = new pt[80];
    g1010 = new pt[100], g1012 = new pt[120], g1210 = new pt[120];

    for (int i = 0; i < 6; ++i) 
        for (int j = 0; j < 6; ++j)
            in_0 >> arr[i][j];
    get_step(6, 6, arr, g66);

    for (int i = 0; i < 6; ++i) 
        for (int j = 0; j < 8; ++j) 
            in_1 >> arr[i][j];
    get_step(6, 8, arr, g68);
    get_step(8, 6, arr, g86);

    for (int i = 0; i < 8; ++i) 
        for (int j = 0; j < 8; ++j) 
            in_2 >> arr[i][j];
    get_step(8, 8, arr, g88);

    for (int i = 0; i < 8; ++i) 
        for (int j = 0; j < 10; ++j)   
            in_3 >> arr[i][j];
    get_step(8, 10, arr, g810);
    get_step(10, 8, arr, g108);

    for (int i = 0; i < 10; ++i) 
        for (int j = 0; j < 10; ++j) 
            in_4 >> arr[i][j];
    get_step(10, 10, arr, g1010);

    for (int i = 0; i < 10; ++i) 
        for (int j = 0; j < 12; ++j)
            in_5 >> arr[i][j];
    get_step(10, 12, arr, g1012);
    get_step(12, 10, arr, g1210);
}

bool Horse::partition(int rr, int cc, int off_x, int off_y) {
    cout << "partition" << endl;
    int r1, r2, c1, c2;
    vector<int> x(8), y(8), p(8);
    // 删除不符合条件的情况
    if (rr % 2 == 1 || cc % 2 == 1 || rr - cc > 2 || cc - rr > 2 || rr < 6 || cc < 6) return true;
    if (rr < 12 || cc < 12) { // 只有一个方向需要切割
        base(rr, cc, off_x, off_y);
        return false;
    }

    // 分成四块 并进行递归分割
    r1 = rr / 2;
    if (rr % 4 > 0) --r1;
    r2 = rr - r1;
    c1 = cc / 2;
    if (cc % 4 > 0) --c1;
    c2 = cc - c1;
    partition(r1, c1, off_x, off_y);
    partition(r1, c2, off_x, off_y + c1);
    partition(r2, c1, off_x + r1, off_y);
    partition(r2, c2, off_x + r1, off_y + c1);

    // 子块完成标号之后，合并进行父块的标号
    x[0] = off_x + r1 - 1, x[1] = x[0] - 1, x[2] = x[1] - 1, x[3] = x[2] + 2;
    x[4] = x[3] + 1, x[5] = x[4] + 1, x[6] = x[5] + 1, x[7] = x[6] - 2;
    y[0] = off_y + c1 - 3, y[1] = y[0] + 2, y[2] = y[1] + 2, y[3] = y[2] - 1;
    y[4] = y[3] + 2, y[5] = y[4] - 2, y[6] = y[5] - 2, y[7] = y[6] + 1;

    for (int i = 0; i < 8; ++i) {
        p[i] = get_pos(x[i], y[i], c);
    }
    for (int i = 1; i < 8; i += 2) {
        int j_1 = (i + 1) % 8, j_2 = (i + 2) % 8;
        if (loop[x[i]][y[i]].x == p[i - 1]) loop[x[i]][y[i]].x = p[j_1];
        else loop[x[i]][y[i]].y = p[j_1];
        if (loop[x[j_1]][y[j_1]].x == p[j_2]) loop[x[j_1]][y[j_1]].x = p[i];
        else loop[x[j_1]][y[j_1]].y = p[i];
    }

    return false;
}

// 递归的基础
void Horse::base(int rr, int cc, int offx, int offy) {
    if(rr==6 && cc==6)
		build(rr,cc,offx,offy,c,g66);
	if(rr==6 && cc==8)
		build(rr,cc,offx,offy,c,g68);
	if(rr==8 && cc==6)
		build(rr,cc,offx,offy,c,g86);
	if(rr==8 && cc==8)
		build(rr,cc,offx,offy,c,g88);
	if(rr==8 && cc==10)
		build(rr,cc,offx,offy,c,g810);
	if(rr==10 && cc==8)
		build(rr,cc,offx,offy,c,g108);
	if(rr==10 && cc==10)
		build(rr,cc,offx,offy,c,g1010);
	if(rr==10 && cc==12)
		build(rr,cc,offx,offy,c,g1012);
	if(rr==12 && cc==10)
		build(rr,cc,offx,offy,c,g1210);
}  

void Horse::build(int rr, int cc, int off_x, int off_y, int col, pt* b) {
    int k = rr * cc;
    for (int i = 0; i < k; ++i) {
        int x_1 = off_x + b[i].x, y_1 = off_y + b[i].y, 
        x_2 = off_x + b[(i + 1) % k].x, y_2 = off_y + b[(i + 1) % k].y;
        int p = get_pos(x_1, y_1, col);
        int q = get_pos(x_2, y_2, col);
        loop[x_1][y_1].x = q;
        loop[x_2][y_2].y = p;
    }
    cout << "build" << endl;
}

int Horse::get_pos(int x, int y, int col) {
    return col * x + y;
}



void Horse::get_step(int rr, int cc, const vector<vector<int>>& a, pt* b) {
    if (rr < cc) {
        for (int i = 0; i < rr; ++i)
            for (int j = 0; j < cc; ++j) {
                int tmp = a[i][j] - 1;
                b[tmp].x = i;
                b[tmp].y = j;
            }
    }
    else {
        for (int i = 0; i < rr; ++i) {
            for (int j = 0; j < cc; ++j) {
                int tmp = a[j][i] - 1;
                b[tmp].x = i;
                b[tmp].y = j;
            }
        }
    }
    cout << "get_step" << endl;
}

void Horse::print(int rr, int cc, ofstream& out) {
    int i, j, k, x, y, p, arr[20][20]{{0}};

    if (partition(rr, cc, 0, 0)) return ;
    i = 0, j = 0, k = 2;
    arr[0][0] = 1;

    out << "(0,0)" << "";
    for (p = 1; p < rr * cc; ++p) {
        x = loop[i][j].x;
        y = loop[i][j].y;
        i = x / cc, j = x % cc;
        if (arr[i][j] > 0) {
            i = y / cc;
            j = y % cc;
        }
        arr[i][j] = k;
        ++k;
        out << "(" << i << "," << j << ")";
        if ((k - 1) % cc == 0) out << endl;
    }
    out << endl;

    for (i = 0; i < rr; ++i) {
        for (j = 0; j < cc; ++j) {
            out << arr[i][j] << " ";
        }
        out << endl;
    }

    cout << "print" << endl;
}

int main() {
    int m, n;
    string file = get_current_dir_name();
    ifstream in(file + "/cpp/course/algorithm_analyse/2_2_input.txt", ios::in);
    ofstream out(file + "/cpp/course/algorithm_analyse/2_2_output.txt", ios::out);

    while (!in.eof()) {
        in >> m >> n;
        cout << m << n << endl;
        Horse h(m, n);
        h.partition(m, n, 0, 0);
        out << m << " " << n << ":" << endl;
        h.print(m, n, out);
        out << endl;
    }

    in.close();
    out.close();
    return 0;
}
```

输入：

```
6 6
8 6
8 8 
8 10
10 8
10 10
10 12
12 10 
12 12
```

输出：

```
6 6:
(0,0)(2,1)(4,0)(5,2)(4,4)(2,3)
(0,4)(2,5)(1,3)(0,5)(2,4)(4,5)
(5,3)(3,2)(5,1)(3,0)(1,1)(0,3)
(1,5)(3,4)(5,5)(4,3)(3,1)(5,0)
(4,2)(5,4)(3,5)(1,4)(0,2)(1,0)
(2,2)(0,1)(2,0)(4,1)(3,3)(1,2)

1 32 29 18 7 10 
30 17 36 9 28 19 
33 2 31 6 11 8 
16 23 14 35 20 27 
3 34 25 22 5 12 
24 15 4 13 26 21 

8 6:
(0,0)(2,1)(1,3)(0,5)(2,4)(4,3)
(3,5)(1,4)(0,2)(1,0)(3,1)(5,2)
(7,1)(5,0)(4,2)(5,4)(7,5)(6,3)
(4,4)(3,2)(4,0)(6,1)(7,3)(6,5)
(5,3)(4,5)(6,4)(7,2)(6,0)(4,1)
(2,0)(0,1)(2,2)(3,4)(5,5)(7,4)
(6,2)(7,0)(5,1)(3,0)(1,1)(0,3)
(1,5)(2,3)(0,4)(2,5)(3,3)(1,2)

1 32 9 42 45 4 
10 41 48 3 8 43 
31 2 33 44 5 46 
40 11 20 47 34 7 
21 30 15 6 19 26 
14 39 12 25 16 35 
29 22 37 18 27 24 
38 13 28 23 36 17 

8 8:
(0,0)(2,1)(4,0)(5,2)(7,1)(5,0)(3,1)(2,3)
(3,5)(4,3)(2,4)(0,5)(1,7)(3,6)(4,4)(3,2)
(2,0)(0,1)(1,3)(2,5)(4,6)(3,4)(5,5)(6,7)
(7,5)(6,3)(4,2)(5,4)(3,3)(4,1)(6,0)(7,2)
(6,4)(7,6)(5,7)(4,5)(6,6)(4,7)(2,6)(0,7)
(1,5)(2,7)(0,6)(1,4)(0,2)(1,0)(2,2)(0,3)
(1,1)(3,0)(5,1)(7,0)(6,2)(7,4)(5,3)(6,1)
(7,3)(6,5)(7,7)(5,6)(3,7)(1,6)(0,4)(1,2)

1 18 45 48 63 12 43 40 
46 49 64 19 44 41 62 13 
17 2 47 8 11 20 39 42 
50 7 16 29 22 9 14 61 
3 30 27 10 15 36 21 38 
6 51 4 55 28 23 60 35 
31 56 53 26 33 58 37 24 
52 5 32 57 54 25 34 59 

8 10:
(0,0)(1,2)(0,4)(1,6)(0,8)(2,9)(1,7)(0,9)(2,8)(4,9)
(6,8)(7,6)(6,4)(4,3)(3,5)(5,6)(4,4)(2,5)(3,7)(4,5)
(3,3)(5,2)(3,1)(2,3)(4,2)(5,0)(7,1)(6,3)(5,5)(3,4)
(2,6)(4,7)(3,9)(1,8)(0,6)(1,4)(0,2)(1,0)(2,2)(4,1)
(6,0)(7,2)(5,3)(3,2)(2,0)(0,1)(1,3)(0,5)(2,4)(3,6)
(4,8)(2,7)(4,6)(5,4)(7,5)(6,7)(7,9)(5,8)(6,6)(7,4)
(6,2)(7,0)(5,1)(3,0)(1,1)(0,3)(1,5)(0,7)(1,9)(3,8)
(5,9)(7,8)(5,7)(6,9)(7,7)(6,5)(7,3)(6,1)(4,0)(2,1)

1 46 37 66 3 48 35 68 5 8 
38 65 2 47 36 67 4 7 34 69 
45 80 39 24 49 18 31 52 9 6 
64 23 44 21 30 15 50 19 70 33 
79 40 25 14 17 20 53 32 51 10 
26 63 22 43 54 29 16 73 58 71 
41 78 61 28 13 76 59 56 11 74 
62 27 42 77 60 55 12 75 72 57 

10 8:
(0,0)(2,1)(4,0)(6,1)(8,0)(9,2)(7,1)(9,0)
(8,2)(9,4)(8,6)(6,7)(4,6)(3,4)(5,3)(6,5)
(4,4)(5,2)(7,3)(5,4)(3,3)(2,5)(1,3)(3,2)
(2,4)(0,5)(1,7)(3,6)(5,5)(4,3)(6,2)(7,4)
(9,3)(8,1)(6,0)(4,1)(2,0)(0,1)(2,2)(1,4)
(0,6)(2,7)(3,5)(2,3)(0,2)(1,0)(3,1)(5,0)
(4,2)(6,3)(8,4)(7,2)(6,4)(4,5)(5,7)(7,6)
(9,7)(8,5)(6,6)(4,7)(2,6)(0,7)(1,5)(0,3)
(1,1)(3,0)(5,1)(7,0)(9,1)(8,3)(9,5)(8,7)
(7,5)(9,6)(7,7)(5,6)(3,7)(1,6)(0,4)(1,2)

1 38 45 64 79 26 41 62 
46 65 80 23 40 63 78 27 
37 2 39 44 25 22 61 42 
66 47 24 21 14 43 28 77 
3 36 49 30 17 54 13 60 
48 67 18 15 20 29 76 55 
35 4 31 50 53 16 59 12 
68 7 52 19 32 73 56 75 
5 34 9 70 51 58 11 72 
8 69 6 33 10 71 74 57 

10 10:
(0,0)(2,1)(4,0)(6,1)(8,0)(9,2)(7,1)(9,0)(8,2)(9,4)
(8,6)(9,8)(7,9)(8,7)(9,9)(7,8)(9,7)(8,9)(6,8)(4,9)
(2,8)(0,9)(1,7)(3,6)(4,4)(5,2)(3,3)(4,5)(2,6)(1,4)
(3,5)(4,7)(6,6)(5,4)(6,2)(7,4)(5,3)(4,1)(6,0)(7,2)
(6,4)(4,3)(5,5)(3,4)(4,6)(5,8)(3,9)(2,7)(1,9)(0,7)
(1,5)(2,3)(0,2)(1,0)(3,1)(5,0)(4,2)(6,3)(8,4)(7,6)
(9,5)(8,3)(9,1)(7,0)(5,1)(3,0)(2,2)(0,1)(2,0)(3,2)
(1,1)(0,3)(2,4)(0,5)(1,3)(2,5)(0,6)(1,8)(3,7)(5,6)
(7,5)(6,7)(5,9)(3,8)(5,7)(6,5)(7,3)(8,1)(9,3)(8,5)
(7,7)(9,6)(8,8)(6,9)(4,8)(2,9)(0,8)(1,6)(0,4)(1,2)

1 68 53 72 99 74 77 50 97 22 
54 71 100 75 30 51 98 23 78 49 
69 2 67 52 73 76 29 48 21 96 
66 55 70 27 44 31 24 79 84 47 
3 38 57 42 25 28 45 32 95 20 
56 65 26 37 34 43 80 85 46 83 
39 4 35 58 41 86 33 82 19 94 
64 7 40 87 36 81 60 91 16 13 
5 88 9 62 59 90 11 14 93 18 
8 63 6 89 10 61 92 17 12 15 

10 12:
(0,0)(1,2)(2,0)(0,1)(1,3)(0,5)(1,7)(0,9)(1,11)(3,10)(5,11)(7,10)
(9,11)(8,9)(9,7)(8,5)(9,3)(8,1)(7,3)(5,4)(6,6)(7,4)(5,5)(4,7)
(2,6)(4,5)(3,7)(1,8)(3,9)(5,8)(7,9)(6,7)(4,8)(5,10)(6,8)(7,6)
(5,7)(4,9)(2,8)(3,6)(2,4)(1,6)(3,5)(4,3)(6,4)(5,6)(4,4)(3,2)
(5,3)(7,2)(5,1)(6,3)(8,4)(6,5)(7,7)(9,8)(8,6)(7,8)(5,9)(3,8)
(4,6)(3,4)(4,2)(2,3)(0,4)(2,5)(3,3)(1,4)(0,6)(2,7)(0,8)(1,10)
(3,11)(2,9)(0,10)(2,11)(4,10)(6,11)(8,10)(6,9)(7,11)(9,10)(8,8)(9,6)
(7,5)(9,4)(8,2)(9,0)(7,1)(9,2)(8,0)(6,1)(4,0)(5,2)(6,0)(4,1)
(2,2)(3,0)(1,1)(0,3)(1,5)(0,7)(1,9)(0,11)(2,10)(4,11)(6,10)(8,11)
(9,9)(8,7)(9,5)(8,3)(9,1)(7,0)(6,2)(5,0)(3,1)(1,0)(0,2)(2,1)

1 4 119 100 65 6 69 102 71 8 75 104 
118 99 2 5 68 101 42 7 28 103 72 9 
3 120 97 64 41 66 25 70 39 74 105 76 
98 117 48 67 62 43 40 27 60 29 10 73 
93 96 63 44 47 26 61 24 33 38 77 106 
116 51 94 49 20 23 46 37 30 59 34 11 
95 92 115 52 45 54 21 32 35 80 107 78 
114 89 50 19 22 85 36 55 58 31 12 81 
91 18 87 112 53 16 57 110 83 14 79 108 
88 113 90 17 86 111 84 15 56 109 82 13 

12 10:
(0,0)(2,1)(0,2)(1,0)(3,1)(5,0)(7,1)(9,0)(11,1)(10,3)
(11,5)(10,7)(11,9)(9,8)(7,9)(5,8)(3,9)(1,8)(3,7)(4,5)
(6,6)(4,7)(5,5)(7,4)(6,2)(5,4)(7,3)(8,1)(9,3)(8,5)
(9,7)(7,6)(8,4)(10,5)(8,6)(6,7)(7,5)(9,4)(8,2)(6,3)
(4,2)(6,1)(5,3)(3,4)(4,6)(6,5)(4,4)(2,3)(3,5)(2,7)
(1,5)(3,6)(4,8)(5,6)(7,7)(8,9)(6,8)(8,7)(9,5)(8,3)
(6,4)(4,3)(2,4)(3,2)(4,0)(5,2)(3,3)(4,1)(6,0)(7,2)
(8,0)(10,1)(11,3)(9,2)(10,0)(11,2)(10,4)(11,6)(10,8)(9,6)
(11,7)(10,9)(8,8)(6,9)(5,7)(4,9)(2,8)(0,9)(1,7)(2,9)
(0,8)(1,6)(0,4)(2,5)(0,6)(1,4)(2,2)(0,3)(1,1)(3,0)
(5,1)(7,0)(9,1)(11,0)(10,2)(11,4)(10,6)(11,8)(9,9)(7,8)
(5,9)(3,8)(1,9)(0,7)(2,6)(0,5)(1,3)(0,1)(2,0)(1,2)

1 118 3 98 93 116 95 114 91 88 
4 99 120 117 96 51 92 89 18 113 
119 2 97 48 63 94 115 50 87 90 
100 5 64 67 44 49 52 19 112 17 
65 68 41 62 47 20 45 22 53 86 
6 101 66 43 26 23 54 85 16 111 
69 42 25 40 61 46 21 36 57 84 
102 7 70 27 24 37 32 55 110 15 
71 28 39 60 33 30 35 58 83 56 
8 103 74 29 38 59 80 31 14 109 
75 72 105 10 77 34 107 12 79 82 
104 9 76 73 106 11 78 81 108 13 

12 12:
(0,0)(2,1)(4,0)(5,2)(4,4)(2,3)(0,4)(2,5)(1,3)(0,5)(2,4)(4,5)
(3,7)(4,9)(5,11)(3,10)(1,11)(0,9)(1,7)(3,6)(5,7)(3,8)(5,9)(4,11)
(2,10)(0,11)(1,9)(2,11)(0,10)(2,9)(4,10)(5,8)(4,6)(2,7)(0,6)(1,8)
(3,9)(4,7)(2,6)(0,7)(2,8)(1,6)(0,8)(1,10)(3,11)(5,10)(4,8)(5,6)
(6,8)(7,10)(9,11)(11,10)(10,8)(11,6)(9,7)(10,9)(11,11)(9,10)(7,11)(6,9)
(7,7)(9,6)(11,7)(9,8)(11,9)(10,11)(8,10)(6,11)(7,9)(8,11)(6,10)(8,9)
(10,10)(11,8)(10,6)(8,7)(6,6)(7,8)(9,9)(10,7)(8,6)(6,7)(8,8)(7,6)
(8,4)(10,5)(11,3)(9,2)(11,1)(9,0)(7,1)(6,3)(7,5)(9,4)(11,5)(10,3)
(9,1)(11,0)(10,2)(11,4)(9,5)(7,4)(6,2)(7,0)(8,2)(6,1)(8,0)(10,1)
(9,3)(7,2)(6,0)(8,1)(10,0)(11,2)(10,4)(8,3)(6,4)(8,5)(7,3)(6,5)
(5,3)(3,2)(5,1)(3,0)(1,1)(0,3)(1,5)(3,4)(5,5)(4,3)(3,1)(5,0)
(4,2)(5,4)(3,5)(1,4)(0,2)(1,0)(2,2)(0,1)(2,0)(4,1)(3,3)(1,2)

1 140 137 126 7 10 35 40 43 18 29 26 
138 125 144 9 136 127 42 19 36 27 44 17 
141 2 139 6 11 8 39 34 41 30 25 28 
124 131 122 143 128 135 20 13 22 37 16 45 
3 142 133 130 5 12 33 38 47 14 31 24 
132 123 4 121 134 129 48 21 32 23 46 15 
111 106 103 92 117 120 77 82 49 60 71 68 
104 91 110 119 102 93 84 61 78 69 50 59 
107 112 105 116 85 118 81 76 83 72 67 70 
90 97 88 109 94 101 62 55 64 79 58 51 
113 108 99 96 115 86 75 80 53 56 73 66 
98 89 114 87 100 95 54 63 74 65 52 57 
```

2_10

```c++
# include <iostream>
# include <vector>
using namespace std;

/*
从1到2n开始顺序放置每个数，对于当前的数k，它的放置方式有两种
1. 放在第一行最左边的空位上
2. 放在第二行最左边的空位上
第二种操作只有在第一行的数比第二行的数多的情况下才能实行
这样的情形可以很好的和序列出入栈对应起来，
将1看成是入栈操作  2看成是出栈操作 只有在栈不为空的情况下才可以进行出栈操作
这样 这个问题就转化为了 求合法的出栈序列个数的问题
我们将 +1 记为入栈，将 -1 记为出栈，那么所有的序列个数为 C(2n, n)
对于每一个不合法的序列，它必定有一个前缀和是小于0的  否则他就是一个合法的序列了
将这个前缀和中每个元素取反，那么就会得到n + 1个 +1 和n - 1个 -1，所有不合法的序列个数就是 C(2n, n + 1)
所有最后的结果就是 C(2n, n) - C(2n, n + 1)
*/

int main() {
    int n;
    cin >> n;
    vector<long long> ctl(n + 1);
    
    ctl[0] = 1;
    for (int i = 1; i <= n; ++i) {
        ctl[i] = (4 * i - 2) * ctl[i - 1] / (i + 1);
    }

    cout << ctl[n] << endl;

    return 0;
}
```

运行截图![](/home/dawn/Pictures/Screenshots/Screenshot from 2023-03-13 12-34-13.png)
### 数据结构与算法

#### 一. 基础知识    

**术语**:

1. 数据: 存储在计算机中可以用二进制表示的内容
2. 数据元素：在计算机中作为一个整体考虑和处理的对象 是组成数据的基本单位 由若干数据项组成
3. 数据对象: 性质相同的数据元素的集合
4. 数据结构: 研究数据与数据之间关系的一门学科
   1. 数据结构的逻辑结构: DS = (D, R) 数据集加关系集
   2. 数据结构的存储结构:
        四种基本的存储结构
      1. 顺序存储
      2. 链式存储
      3. 索引存储
      4. 哈希存储 
   3. 数据的操作实现
5. 抽象数据类型(ADT): ADT = （D, R, P) 数据对象 + 关系 + 操作

**算法的特性**:

1. 有穷性
2. 确定性
3. 可行性
4. 有输入输出
5. 通用性
6. 可读性
7. 健壮性

**算法分析**

- 时间复杂度

- 空间复杂度

  

#### 二. 线性表

1. **定义**: 由长度为n的一组结点组成的有限序列

2. **顺序存储结构**: 也称为顺序表

   1. 特点:

       - 逻辑顺序与物理顺序一致
       - 元素之间的关系用物理位置的相邻来体现

   2. 形式定义:

       ```cpp
       template <class Elem> 
       class  Alist: public list<Elem> {
       	private:  
       		int maxSize, listSize, curr; // 线性表最大长度、表长、当前元素位置
       		Elem * listArray;	
       	public:
         	 	Alist(int size=DefaultListSize) { 	//构造函数
         			maxsize=size; listSize = curr =0;
           			listArray = new Elem[ maxSize ]; 
       		}
         		~Alist() {  delete [ ] listArray; }		// 析构函数
       		void clear(){ listSize = curr =0; }		//清空线性表
       		void Prev( ){ if (curr>0) curr--; }		//当前位置curr前移到前驱
       		void Next( ){ if (curr<listSize-1) curr++;}	//当前位置curr后移到后继
       		bool setPos(int pos);	  		//任意指定当前数据元素的位置
       		bool insert(const Elem it); 		//在当前位置插入元素
       		bool append(const Elem it);		//在表尾插入元素
       		bool remove( Elem &it);		//删除当前位置元素并返回其值
       		….       //其它操作的实现
       };
       ```

   3. 操作实现

       1. 插入操作
           1. 实现
           2. 时间复杂度分析
       2. 追加操作
           1. 实现
           2. 时间复杂度分析
       3. 删除操作
           1. 实现
           2. 时间复杂度分析

3. **链式存储结构:**　简称链表

   1. 特点：
      1. 插入和删除操作时不需要移动元素
      2. 不要求逻辑上相邻的元素在物理位置上也必须相邻
   2. 分类：
      1. **单链表**：
         1. 简述：单链表中每个元素用一个结点来存储，每个结点包括数据域和指针域，单链表的指针域中只包含一个指针
         2. 一些概念：
            1. 头结点：在链表最前端不存储任何数据元素的结点
            2. 头指针：指向头结点
            3. 空表：仅有一个头结点的单链表是空表
         3. 操作实现：
            1. 单链表节点以及单链表的定义
            2. 单链表的建立
            3. 读取元素
            4. 插入
            5. 删除
      2. **双向链表**：
         1. 简述：双向链表的指针域中包括两个指针(前驱和后继)
         2. 操作实现:
            1.  双向链表节点以及双向链表的定义
            2. 插入
            3. 删除
      3. **循环链表**：
         1. 如果是单向循环链表，尾节点的next指向头节点，如果是双向循环链表，尾节点的next指向头节点，头节点的pre指向尾节点
         2. 循环条件判定：当前节点是否等于头节点
         3. 操作实现：
            1. 定义
            2. 应用: 约瑟夫环

4. **两种方法的对比及改进**

   1. 对比：
      1. 空间上：顺序表没有浪费空间，链表存在指针域开销
      2. 访问上：顺序表可以随机访问，仅需O(1)复杂度，链表只能顺序访问，需要O(n)复杂度
      3. 插入删除上：顺序表插入删除复杂度为O(n), 链表插入删除复杂度为O(1)
   2. 改进：
      1. 空闲链管理空闲的空间
      2. 静态链表：静态链表的空间是一组地址连续的内存空间，数据元素包括数值域和下标域，每个元素所存的下标即为next。需要用一个空闲链来管理连续空间中未使用的空间

5. **线性表的应用**：

   1. 一元多项式的表示:

      1. 表示方法一：采用顺序表，用下标来表示指数，数据来表示相应系数，适用于密集多项式
      2. 表示方法二：采用链表，每个节点中存储指数和系数，适用于稀疏多项式

   2. 商品链的更新：采用链表







#### 三.受限线性表

1. ##### 栈:

   1. 特点: 仅在表的尾部进行插入和删除的线性表，具有先进后出(FILO)、后进先出(LIFO)的特点

   2. 一些属性
      1. 栈顶：进行插入和删除操作的一端
      2. 出栈、入栈

   3. 存储结构：
      1. 顺序栈 -- 栈的顺序存储结构
         1. 简述：用数组存储数据，两个指针一个指向栈顶，一个指向栈底
         2. 溢出：上溢 -- 对满栈进行push  下溢 -- 对空栈进行pop   **为了防止溢出，入栈出栈前要检查**  采用栈顶对栈顶，两个栈共用空间的方法可以提高空间利用率、降低上溢的发生概率
         3. 操作实现：
            1. 创建
            2. 入栈出栈 push() pop() 
            3. 返回栈顶元素 top()
      2. 链栈  --  栈的链式存储结构
         1. 简述：本质是一个单链表，但是它所能进行的操作是有限制的，只能在表头插入删除
         2. 头节点：若有头节点，那么栈顶元素存在头节点的next节点、栈顶指针指向头节点，否则，栈顶指针指向栈顶元素  **默认链栈不带头节点**
         3. 操作实现：
            1. 链栈节点以及链栈的定义
            2. 销毁
            3. 求长度
            4. 返回栈顶
            5. 入栈出栈

   4. **出栈规律**：

      任何出栈的元素后面出栈的元素都必须满足以下三点规律

      1. 在原序列中相对位置比它小的元素，必须是逆序
      2. 在原序列中相对位置比它大的元素，顺序没有限制
      3. 以上两条可以交叉使用

   5. **栈的应用**
      1. 括号匹配
         1. 思路简述：如果碰到左括号，就将其入栈；如果碰到右括号，就取出栈顶元素，判断二者是否匹配
         2. 代码实现：
         
      2. 递归和栈
         1. 每一个函数被调用时，为它在栈顶分配一个存储区，当函数返回时，就从栈顶释放存储区
         2. 函数返回的过程：1. 从栈顶弹出工作记录   2. 将工作记录中的参数赋给对应变量   3.将函数的返回值赋给对应变量   4. 转移到返回地址
         
      3. **表达式求值**：
         1. 将中序表达式转换为后序表达式
         2. 对后续表达式进行求值
         
         

2. ##### 队列：

   1. 特点：仅能在一端进行插入操作，而在另一端进行删除操作的线性表；具有先进先出(FIFO)、后进后出(LILO)的特点
   2. 一些属性和成员：
      1. 队尾：进行插入操作的一端
      2. 队头：进行删除操作的一端
      3. 入队、出队

   3. 操作实现：
      1. 创建
      2. 销毁
      3. 插入、删除
      4. 返回队头
      5. 返回长度

   4. 存储结构：
      1. 顺序队列：
         1. 简述：利用头指针(front)和尾指针(rear)来记录队列头和队列尾的位置
         2. 操作实现：
            1. 入队：将元素放置rear指向的位置，然后将rear + 1
            2. 出队：将front + 1
            3. 判断是否为空：front == rear 

      2. 循环队列:
         1. 简述：头尾相连的顺序队列
         2. 操作实现：
            1. 入队：区别在于 rear = (rear + 1) % max_size
            2. 出队: 区别在于 front = (front + 1) % max_size
            3. 判断是否为空：同上
            4. 判断是否为满：front = (rear + 1) % max_size

      3. 链队列

   5. 队列的应用：
      1. 计算杨辉三角
      2. 火车车厢重排
      
      

3. ##### 字符串

   1. 定义：n个字符的一个有序序列

   2. 操作实现：
      1. 求长度
      2. 赋值
      3. 将两个串连接
      4. 比较大小
      5. 查找是否存在某字符或某字符串
      6. 截取生成子串
      7. 插入字符或字符串
      8. 删除字符或子串

   3. 存储结构：
      1. 静态存储(顺序存储)：
         1. 缺点：
            1. 需要预先定义大小，如果定义的max_length过大，则会浪费空间；
            2. 因为有最大字符数，所以会使某些可能改变长度的操作受到限制
      2. 动态存储(链式存储) :
         1. 类型：
            1. 每个节点存一个字符：优点是便于插入删除，缺点是浪费空间
            2. 每个节点存K个字符：优点是提高了存储密度，缺点是插入删除很不方便

   4. **模式匹配**：

      1. 定义：模式匹配是指 子串(模式串)在主串中的定位

      2. 算法：

         - Brute-Force算法：依次遍历，判断是否匹配

         - KMP算法：

           - 前缀表：

             - 作用：在匹配发生错误时，回退到上次已经匹配过的地方，减少从头匹配

             - 意义：用next数组来表示前缀表，对于一个字符串来说，它对应的next数组中，next[i]是从头开始的长度为i + 1的子串的最长相等前后缀的长度

             - 如何求next数组

               ```c++
               /*
               求next数组 可以看成是模式串与模式串进行匹配的一个过程 当未匹配时 利用前面已经完成的next数组进行跳转
               */
               vector<int> next;
               void getNext(string s) {
                   int j = 0;// j是前缀末尾的下标
                   next[0] = 0; // 显然next[0] = 0
               
                   for (int i = 1; i < s.size(); ++i) { // i是后缀末尾的下标
                       // 当s[i]和s[j]不匹配时 j就回退到之前已经匹配的位置
                       while (j > 0 && s[i] != s[j]) j = next[j - 1]; 
                       // 匹配成功时 将长度加一
                       if (s[i] == s[j]) ++j;
                       // 每个下标处都进行记录
                       next[i] = j;
                   }
               }
               ```

               

             - 如何查找

               ```c++
               /*
               haystack为主串 needle为模式串
               */
               int strStr(string haystack, string needle) {
                   int n = needle.size(), j = 0; // j是指向模式串当前位置的指针
                   next.assign(n, 0);
                   getNext(needle);
               	// i是指向主串当前位置的指针
                   for (int i = 0; i < haystack.size(); ++i) {
                       // 匹配失败 回退
                       while (j > 0 && haystack[i] != needle[j]) j = next[j - 1];
                       // 匹配成功
                       if (haystack[i] == needle[j]) ++j;
                       // 成功找到模式串 返回起始位置
                       if (j == needle.size()) return i - j + 1;
                   }
               
                   return -1;	
               }
               ```






#### 四. 扩展线性表

1. **数组**：

      1. 定义：由n个具有相同数据类型的数据元素组成的有序序列，且该序列必须存储在一块地址连续的存储单元中
      2. 特点：元素类型相同   支持随机存取   元素个数固定
      3. 操作实现： 随机存取   随机修改   初始化
      4. 存储结构：
            . 静态数组(定义数组)：
                	1. 维数：一维  多维
                            	2. 压缩存储：多个值相同的矩阵元素分配到一个存储空间，值为0的矩阵元素不分配空间的存储方式

            ​    

2. **广义表**：

      1. 定义：广义表L是由n个元素组成的有穷序列，其中每个元素可以是原子项或者广义表
      2. 概念：
         1. 表头：非空广义表的第一个元素为表头，表头可以是原子或者广义表
         2. 表尾：除去第一个元素外其他元素组成的表为表尾，表尾一定是广义表

      3. 存储方式：
         1. 头尾链表存储：
               1. 节点分类：
                     1. 表节点 由标识域 头指针域和尾指针域组成 (标识域是用来区分表节点和原子节点的)
                     2. 原子节点 由标识域和值域组成
               2. 特点：
               3. 实现：
         2. 扩展线性链表存储:
            1. 节点组成：
               1. 标志域：用来表明节点类型  为0代表是附加头节点  为1代表是原子节点  为2代表是子表
               2. 信息域：节点为附加头节点时，存储引用计数；为原子节点时，存储数据值；为子表节点时，存储子表的表头指针
               3. 尾指针域：节点为附加头节点时，存放头指针；否则，存放同层下一个节点的地址
            2. 特点:
      4. **递归操作：**
         1. 取表头 取表尾
         2. 复制
         3. 求长度
         4. 求深度




#### 五. 树和二叉树





1. **树**：

      1. 定义：树是包含n个节点的有限集合，n = 0时为空树，n不为0是非空树，                                                                      在一棵非空树T中，有以下两个特点：

            1. 有且仅有一个特定的节点R作为树的根节点
            2. 除根节点外的节点可以被分为m个互不相交的有限集合T1 --> Tm, 其中每个集合本身也是一棵树，称为树T的子树，每个子树都有对应的根节点R1 -- > Rm，称为R的孩子

      2. 术语：

            1. 节点的度：节点拥有的子树个数
            2. 树的度：树内节点的度的最大值
            3. 叶子节点：度为0的节点
            4. 分支节点：度不为0的节点
            5. 孩子节点、双亲节点：树中节点的子树的根是该节点的孩子节点，该节点称为其孩子节点的双亲节点
            6. 兄弟节点：父节点相同的节点
            7. 堂兄弟节点：父节点在同一层的节点
            8. 祖先：一个节点的祖先是从根节点到该节点所经分支上的所有节点
            9. 子孙：一个节点的子孙是以该节点为根的子树中的所有节点
            10. 节点的层次：根节点的层次为1，其余节点的层次为其双亲节点的层次加一
            11. 树的深度：树中节点的最大层次
            12. 树的高度：树的总层数
            13. 有序树：将树中每个节点的各子树看成是从左到右有顺序的
            14. 无序树：将树中每个节点的各子树看成是无顺序的
            15. 森林：m(m >= 0)棵互不相交的树的集合

            

2. **二叉树**

      1. 定义：二叉树是包含n个节点的有限集合，n = 0时为空二叉树，n != 0时为非空二叉树                                             在一棵非空树T中，有以下两个特点:
            1. 有且仅有一个特定的节点R  称为二叉树T的根节点

            2. 除根结点外的其余节点 被分为两个互不相交的有限集合T1、T2，其中T1、T2也是一棵二叉树，这两棵二叉树分别称为 根节点R的左子树和右子树，左子树的根节点称为R的左孩子，右子树的根节点称为R的右孩子



        2. 性质：

           1. 在二叉树的第i层上至多有pow(2, i - 1)个节点 (i >= 1)

           2. 高度为k的二叉树至多有pow(2, k) - 1个节点

           3. 对于任意一个非空二叉树T, 如果其叶子节点的个数为n0，度为2的节点数为n2，则有 n0 = n2 + 1     证明： 记n为节点树，e为边数， 度为1的节点数为n1，                                                                                          则有  n = n0 + n1 + n2 = e + 1 = n1 + 2 * n2 + 1

           4. 对一颗具有n个节点的完全二叉树的节点按层序从左往右编号，则对于任意一个节点 i (0 <= i <= n - 1)有：

              1. 如果2 * i + 1 >= n，则节点i无左孩子，否则，其左孩子的序号为2 * i + 1
              2. 如果2 * i + 2 >= n，则节点i无右孩子，否则，其右孩子的序号为2 * i + 2
              3. 如果 i = 0，则节点i是二叉树的根节点；如果 i > 0，则其双亲节点的序号为

              $$
              \left \lfloor (i - 1) / 2 \right \rfloor
              $$

           5. 具有n个节点的完全二叉树的高度 k = 

           $$
           \left \lfloor \log_2 n \right \rfloor + 1
           $$

           



  3. **满二叉树和完全二叉树**

     1. 满二叉树
        1. 定义: 一棵高度为k并且有 2^k - 1个结点的二叉树
        2. 性质: 
           1. 每一层上的节点数都到达最大值
           2. 不存在度为1的节点
           3. 每个分支节点都有两棵高度相同的子树，所有叶子节点都在最下一层上
        3. 编号: 从0开始编号
     2. **完全二叉树**:
        
        1. 定义: 一棵二叉树每个节点的层序编号与对应位置的满二叉树的层序编号完全一致，则该树为完全二叉树
        2. **性质**：
           
           1. 从满二叉树中连续删除m个元素，其层序编号为2^k - 1 - i，i：from 1 to m, 所得二叉树也是完全二叉树
           2. 完全二叉树中至多只有最下面两层的上的节点的度数小于2，且最下层节点都集中在该层的最左边
           3. 完全二叉树中如果一个节点没有左孩子，那么它也没有右孩子
           
           

  4. 二叉树的存储结构

     1. 顺序存储结构

        1. 简述：将二叉树中的所有节点按照一定的次序存储到一组地址连续的存储单元中

        2. 性质：编号从0开始，则对于节点 i 来说，

           1. 如果2 * i + 1 >= n，则节点i无左孩子，否则，其左孩子的序号为2 * i + 1

           2. 如果2 * i + 2 >= n，则节点i无右孩子，否则，其右孩子的序号为2 * i + 2

           3. 如果 i = 0，则节点i是二叉树的根节点；如果 i > 0，则其双亲节点的序号为
              $$
              \left \lfloor (i - 1) / 2 \right \rfloor
              $$

        3. 如何存储一般的二叉树：对于一般的二叉树来说，将其按照完全二叉树的形式进行存储，其中如果某节点为空，则用特定值表示不存在

     2. 链式存储结构

        1. 简述：指二叉树的各节点随机的存储在内存空间中，节点之间的关系用指针表示
        
        2. 节点组成：至少包括 数据域，左指针域，右指针域
        
        3. 操作实现
           1. 节点类的声明
           
           2. 二叉树类的定义
           
              

  5. **二叉树的遍历**

     二叉树节点定义

     ```c++
     class TreeNode {
     	TreeNode* left;
     	TreeNode* right;
     	int val;
     
     	TreeNode(int v): val(v), left(nullptr), right(nullptr) { };
     };
     ```

     1. 前序遍历

        1. 递归版本

           ```cpp
           void preOrder(TreeNode* root) {
               if (!root) return ;
               
               visit(root);
               preOrder(root->left);
               preOrder(root->right);
           }
           ```

        2. 非递归版本一

           ```c++
           void preOrder(TreeNode* root) {
               stack<TreeNode*> ts;
               TreeNode* cur = root;
               if (cur) ts.push(cur);
               
               while (!ts.empty()) {
                   TreeNode* tmp = ts.top();
                   ts.pop();
                   visit(tmp);
                   
                   if (tmp->right) {
                       ts.push(tmp->right);
                   }
                   if (tmp->left) {
                       ts.push(tmp->left);
                   }
               }
           }
           ```

        3. 非递归版本二

           ```cpp
           void preOrder(TreeNode* root) {
               stack<TreeNode*> ts;
               TreeNode* cur = root;
               
               while (!ts.empty() || cur) { // 当指针为空且栈为空时 停止循环
                   if (cur) { // 中 左
                       visit(cur);
                       ts.push(cur);
                       cur = cur->left;
                   }
                   else { // 右
                       cur = ts.top();
                       ts.pop();
                       cur = cur->right;
                   }
               }
           }
           ```

        

     2. 中序遍历

        1. 递归版本

           ```cpp
           void inOrder(TreeNode* root) {
               if (!root) return;
               
               inOrder(root->left);
               visit(root);
               inOrder(root->right);
           }
           ```

        2. 非递归版本

           ```cpp
           void inOrder(TreeNode* root) {
               stack<TreeNode*> ts;
               TreeNode* cur = root;
               
               while (!ts.empty() || cur) { // 当指针为空且栈为空时 停止循环
                   if (cur) { // 左
                       ts.push(cur);
                       cur = cur->left;
                   }
                   else { // 中 右
                       cur = ts.top();
                       ts.pop();
                       visit(cur);
                       cur = cur->right;
                   }
               }
           }
           ```

        

     3. 后序遍历

        1. 递归版本

           ```cpp
           void postOrder(TreeNode* root) {
               if (!root) return 0;
               
               postOrder(root->left);
               postOrder(root->right);
               visit(root); 
           }
           ```

        2. 非递归版本

           1. 实现

           ```cpp
           // 对TreeNode 新增了一个flag用于标记
           void postOrder(TreeNode* root) {
               TreeNode* cur = root; // 将根节点root赋值给cur
               stack<TreeNode*> ts;
               
               if (cur) {
                   ts.push(cur);
                   cur->flag = 1; // 如果cur不为空, 将cur入栈，将cur->flag设置为1，
                   
                   while (!ts.empty()) { // 当栈不为空时
                       TreeNode* tmp = ts.top();
                       ts.pop(); // 取出栈顶元素赋值给tmp
                       
                       if (tmp->flag == 1) { // 如果tmp->flag为1 
                           ts.push(tmp);
                           tmp->flag = 2;  // 则将其再次入栈 并设置tmp->flag为2
                           if (tmp->right) {
                               ts.push(tmp->right);
                               tmp->right->flag = 1;
                           } // 如果tmp->right不为空 将其入栈 并设置tmp->right->flag为1
                           if (tmp->left) {
                               ts.push(tmp->left);
                               tmp->left->flag = 1;
                           } // 如果tmp->left不为空 将其入栈 并设置tmp->left->flag为1
                       }
                       else { // 如果tmp->flag为2 则访问tmp
                           visit(tmp);
                       }
                   }
               }
           }
           ```

     4. 层序遍历

        1. 非递归版本

           ```c++
           void LevelOrder(TreeNode* root) {
           	queue<TreeNode*> que;
           	TreeNode* cur = root;
           	if (cur) {
           		que.push(cur);
           	}
           	
           	while (!que.empty()) {
           		cur = que.front();
           		que.pop();
           		
           		if (cur->left) {
           			que.push(cur->left);
           		}
           		if (cur->right) {
           			que.push(cur->right);
           		}
           	}
           }
           ```

     

  6. 应用

     1. **哈夫曼树**(最优二叉树)

        1. 定义：假设一棵二叉树有n个节点，节点i的权值为wi (i: from 1 to n)，构造一颗以这n个节点为叶子节点的二叉树，则其中带权路径长度(WPL)最小的二叉树称为哈夫曼树

        2. 术语
           1. 路径：从树中一个节点到另一个节点之间的边构成这两个节点之间的路径
           2. 路径长度：路径上的边数
           3. 树的路径长度：从树的根节点到每个叶子节点的路径长度之和
           4. 叶子的带权路径长度：从该叶子节点到树的根节点的路径长度与该节点的权的乘积
           5. 树的带权路径长度：树中所有叶子节点的带权路径长度之和
           
        3. 构造思路：
           1. 由给定的n个权值{w1, w2, ......, wn}构成含有n棵二叉树的森林，其中每棵二叉树都是只含有一个权值为wi的单根节点
           
           2. 在森林中选取根节点的权值最小的两棵二叉树，分别作为左右子树构造一棵新的二叉树，新的二叉树的根节点的权值为其左右子树上根节点的权值之和
           
           3. 从森林中删除2中选中的两棵树，并将新得到的二叉树加入森林中
           
           4. 重复步骤2 3，直到森林中仅剩下一棵树，这棵树就是哈夫曼树
           
              

     2. 哈夫曼编码

        1. 用处：用来设计二进制的前缀编码

        2. 做法：
           1. 统计字符集中每个字符的使用频率作为权值构造一棵哈夫曼树
           
           2. 从根节点开始，分别将0、1标记在树的每条边上，0和连接到左孩子的边对应，1和连接到右孩子的边对应
           
           3. 从根到叶子节点的路径上的01串，即为该叶子节点的哈夫曼编码
           
              

     3. **二叉查找树**(二叉搜索树) -- BST: Binary Search Tree

        1. 定义：二叉查找树或者是一棵空树，或者是一棵每个节点都具有一个关键值的树，满足以下性质：

           1. 若左子树非空，则左孩子的关键字的值小于其根节点的关键字的值 

              ```c++
              cur->left->key < cur->key
              ```

           2. 若右子树非空，则右子树的关键字的值大于其根节点的关键字的值

              ```c++
              cur->right->key > cur->key
              ```

           3. 左右子树均为二叉查找树

        2. 特点：中序遍历一棵二叉查找树，得到的是一个递增的有序序列

        3. 区分：二叉查找树中不存在关键值相同的节点，二叉排序树中允许存在关键值相同的节点

        4. 操作及其实现

           1. 查找

              1. 思路：

                 ```markdown
                 1. 从根节点开始, 将给定的k与根节点的关键值进行比较，如果相等，则查找成功
                 2. 如果k小于根节点的值，则查找左子树
                 3. 如果k大于根节点的值，则查找右子树
                 4. 直到找到k或者遇到叶子节点为止
                 ```

              2. 实现：

                 ```c++
                 // 返回关键字的值和k相等的节点 没有则返回空
                 TreeNode* search(TreeNode* root, int k) {
                 	if (!root) return nullptr;
                 	
                 	if (k > root->val) {
                         search(root->right, k);
                     }
                     else if (k < root->val) {
                         search(root->left, k);
                     }
                     else return root;
                 }
                 ```

              3. 结论：

                 1. BST中查找次数最多 为 树的高度
                 2. 时间复杂度：理想情况下为O(log n);   最坏情况下为 O(n)

           2. 插入

              1. 思路：

                 ```markdown
                 1. 如果二叉树为空，则生成一个值为k的新节点，令其为二叉查找树的根
                 2. 如果二叉树不为空，则将k与根节点的关键字的值比较，如果相等，则无需插入；如果k小于root->key，则将k插入到左子树中；否则插入到右子树中
                 ```

              2. 实现：

                 ```c++
                 void insert(TreeNode* root, int k) {
                     if (!root) {
                         root = new BinaryTreeNode(k);
                         return ;
                     }
                     
                     if (k == root->key) return ;
                     else if (k < root->key) 
                         insert(root->left, k);
                     else 
                         insert(root->right, k);
                     
                     return ;
                 }
                 ```

              3. 结论：

                 1. 插入的节点一定是叶子节点
                 2. 插入后形成的二叉查找树的好坏，取决于插入的关键字的顺序
                 3. 时间复杂度：与查找相同

           3. 删除

              1. 思路：

                 ```markdown
                 1. 先找到要删除的节点cur
                 2. 当 cur 左子树不为空 右子树为空时 直接将左子树接上去即可
                 3. 当左子树为空 右子树不为空时 直接将右子树接上去
                 4. 当左右子树均为空时 删除cur即可
                 5. 当左右子树均不为空时 
                 	方法一 将左子树 作为右子树的最左侧的节点的左孩子
                 	方法二 用左子树中最大元素 或 右子树中最小元素 来代替该节点
                 ```

              2. 实现

                 ```c++
                 TreeNode* delete_node(TreeNode* cur, int key) {
                     if (!cur) return cur; // 当遇到空节点时 说明没有找到key 直接返回即可
                 
                     if (cur->val > key) cur->left = delete_node(cur->left, key);
                     // key 小于当前节点值时 说明它在左子树上
                     else if (cur->val < key) cur->right = delete_node(cur->right, key);
                     // key 大于当前节点值时 说明它在右子树上
                     else {  // 否则 就cur 就是我们要删除的那个节点
                         if (cur->left && !cur->right) cur = cur->left; 
                         // 当 cur 左子树不为空 右子树为空时 直接将左子树接上去即可
                         else if (!cur->left && cur->right) cur = cur->right;
                         // 当左子树为空 右子树不为空时 直接将右子树接上去
                         else if (!cur->left && !cur->right) cur = NULL;
                         // 当左右子树均为空时 删除cur即可
                         else {
                             TreeNode* tmp = cur->right;
                             while (tmp->left) tmp = tmp->left;
                             tmp->left = cur->left;
                             cur = cur->right;
                         }
                         // 当左右子树均不为空时 将左子树 作为右子树的最左侧的节点的左孩子   并令cur = cur->right
                         // 原因： 左子树上的值均小于右子树 而 右子树上最左侧的节点的值是右子树上最小的
                         // 接上去之后 仍然是满足二叉搜索树的
                     }
                 
                     return cur;
                 }
                 ```

              3. 时间复杂度：与查找相同
              
              

     4. **平衡二叉树**(即 平衡二叉查找树) 

        ​	简称/缩写：BBST —— Balanced Binary Search Tree      AVL树(作者的名字命名)

        1. 定义：平衡二叉树或者是一棵空树，或者是一棵二叉树且满足一下性质：

           1. 左右子树的深度之差的绝对值小于等于1，即|BF(A)| <= 1  (BF: Balance Factor 平衡因子= 左子树的深度减去右子树的深度)
           2. 左右子树都是一棵平衡二叉树

        2. 节点数/深度计算：

           1. 节点数计算：当树的高度为h是，最大节点数为2^h - 1  最小节点数满足斐波那契数列规律 即
              $$
              N_{0} = 0 (表示AVL Tree高度为0的节点总数) 
              \\N_{1} = 1 (表示AVL Tree高度为1的节点总数)
              \\N_{2} = 2 (表示AVL Tree高度为2的节点总数)
              \\N_h = N_{h-1} + N_{h-2} + 1 (表示AVL Tree高度为h的节点总数)
              $$

        3. **平衡旋转化**

           ![](pics\Tree_Rebalancing.png)

           1. 如何判断不平衡情况：找到离插入节点最近的，且平衡因子的绝对值超过1的祖先节点；记录从该祖先节点到插入节点路径的方向，路径方向就是对应的不平衡情况
           2. 不平衡情况分类：
              1. LL: 无需处理
              2. RR: 无需处理
              3. LR: 如果节点r有左子树 作为r的父节点的右子树	如果节点r有右子树 作为r的父节点的父节点的左子树
              4. RL: 如果节点r有右子树 作为r的父节点的左子树

        4. 平衡二叉树的插入

           1. 步骤：

              ```markdown
              1. 按照二叉查找树的插入方法，找到插入新元素的位置
              2. 修改从根节点到插入节点路径上所有节点的平衡因子
              3. 判断是否产生不平衡
              4. 若不平衡，则确定不平衡类型；进行相应的平衡旋转化，然后结束插入
              5. 若平衡，则结束插入
              ```

        

     5. **堆和优先队列**

        1. 定义

           1. 优先队列：按照优先级或重要性来组织的对象
           2. 堆：
              1. 堆是一个数组
              2. 在一个堆中，对于任意一个非终结节点A，A的关键值大于等于(大根堆)其任意一个孩子节点的关键值 / A的关键值小于等于(小根堆)其任意一个孩子节点的关键值 

        2. 堆的性质：

           1. 堆从逻辑上来讲是一棵完全二叉树，因此我们可以用数组来表示堆

        3. 操作及其实现

           1. 插入

              1. 思路

                 ```markdown
                 1. 将新元素放到数组末尾
                 2. 将该元素与它的父亲进行比较, 判断是否符合堆的性质, 不符合就交换
                 3. 重复2，直到符合堆的性质为止
                 ```

              2. 时间复杂度： 最坏情况为O(log n)

              3. 改进： 当插入的所有元素都已知时，使用筛选法建堆更高效

                 1. 筛选法步骤

                    1. 将n个元素保存到数组中，形成一棵完全二叉树
                    2. 从最后一个内部节点开始，从右往左、从下到上依次调整每个内部节点，直到到达根节点，整棵完全二叉树就成为一个堆
                    3. 解释：

                       1. 最后一个内部节点是指在二叉树中倒数第二层最右边的节点，它在数组中的下标是
                          $$
                          \left \lfloor n/2 \right \rfloor - 1
                          $$
                       2. 调整每个内部节点的方式是将它和它的孩子进行比较

                 2. 时间复杂度：进行一次 ShifDown 最多比较2log(n)次, 移动log(n)次，因此最坏情况下时间复杂度为 O(log n)

           2. 删除根节点

              1. 思路：
                 1. 将根节点与最后一个元素互换，然后删除根节点
                 2. 对根节点采用筛选法

  7. **树和森林**

     1. 存储结构

        1. 双亲表示法：每个节点存储自己的父节点
        2. 孩子表示法：每个节点存储自己的孩子节点
        3. 左孩子右兄弟表示法：每个节点中有两个指针域，第一个指向自己最左侧的孩子节点，第二个指向自己右边的兄弟节点

     2. 树、二叉树和森林的转换

        1. 树转化为二叉树

           ```
           1. 在所有兄弟节点之间加一条线
           2. 对于每个节点，只保留它和最左边孩子的连线
           3. 以树根为轴心，进行旋转处理
           (每个节点如果有孩子, 则让最左侧的孩子作为它的左孩子, 如果右侧有兄弟节点, 则让右侧的兄弟节点作为它的右孩子)
           ```

        2. 森林转化为二叉树

           ```
           1. 先将森林中的每棵树都转化为二叉树(由1中操作可以 转化所得的二叉树中根节点没有右孩子)
           2. 然后依次将每颗树作为上一颗树的右子树
           ```

        3. 二叉树转化为森林或树: 方法过多 略

     3. 树和森林的遍历

        1. 树的遍历

           1. 先根遍历：最早访问根节点
           2. 后根遍历：最后访问根节点

        2. 森林的遍历

           1. 先根遍历

              ```markdown
              1. 先访问森林中第一棵树的根节点
              2. 先根遍历第一棵树
              3. 先根遍历除去第一棵树后剩余的树构成的森林
              ```

           2. 中根遍历

              ```markdown
              1. 后根遍历第一棵树
              2. 中根遍历除去第一棵树后的剩余的树构成的森林
              ```



#### 六. 图

1. 定义：图G是由表示数据元素的集合V和表示数据元素之间关系的集合E组成的, 记作G = (V, E)

2. 术语：
   1. 顶点：图中的数据元素称为顶点，V是有限非空顶点集
   2. 边：顶点的偶对称为边，E是表示两个顶点之间具有关系的边集合
   3. 无向边、无向图
   4. 有向边、有向图：有向图中有一条边<vi, vj>, 则称vi为弧尾或起点，称vj为弧头或终点
   5. 邻接：无向图中若<vi, vj> ∈ E, 则称vi, vj相邻接；有向图中若<vi, vj> ∈ E，则称vi邻接到vj
   6. 子图：G = (V, E), G' = (V', E'), 如果 V' 是V的子集, E' 是E的子集，并且 E' 中的边仅和 V‘ 中的顶点相关联，则G' 是G的子图
   7. 网：即带权图
   8. 路径：如果顶点vi, vj之间存在一个顶点序列，这个序列中相邻两个顶点组成的偶对均为图中的边，那么成vi到vj之间存在一条路径
   9. 路径的长度：路径上边的数目
   10. 简单路径和回路(环): 简单路径 —— 除起点和终点外，序列中顶点不重复出现的路径； 回路 —— 路径的起点和终点相同
   11. 无环图、有向无环图
   12. **自由树**：无回路的连通无向图
   13. 连通、连通图：如果两个顶点之间有路径可达，则称它们是连通的；如果图中任意两个顶点都是连通的，则该图是连通图
   14. 连通分量：**无向图**的极大连通子图称为这个图的连通分量 （性质：连通图的连通分量是本身，非连通图的连通分量有多个，**连通分量是对无向图的一种划分**）
   15. 强连通图：**有向图**中，如果任意两个顶点vi, vj之间，既有从vi到vj的路径，也有从vj到vi的路径，那么称该图为强连通图
   16. 弱连通图：**有向图**去掉边的方向性之后成为连通图，则该图为弱连通图
   17. 强连通分量：**有向图**的极大强连通子图称为这个图的强连通分量 (性质：强连通图只有一个强连通分量，非强连通图有多个强连通分量)
   18. 度(D(v))、入度(ID(v))、出度(OD(v))：度——关联于该顶点的边数；入度——以该顶点为弧头的边的数目；出度——以该顶点为弧尾的边的数目   D(v) = ID(v) = OD(v)   图的边数 等于 度之和 / 2
   19. 无向完全图：无向图G的顶点数n和边数e满足 0 <= e <= n(n - 1) / 2, 当e = n(n - 1) / 2时，该无向图为无向完全图
   20. 有向完全图：有向图G的顶点数n和边数e满足 0 <= e <= n(n - 1)，当e = n(n - 1)时，该有向图为有向完全图
   21. 稀疏图、稠密图
   22. 生成树：包含图中所有顶点的极小连通子图，有且仅有n - 1条边(图中有n个顶点)
   23. 有向树：恰有一个顶点的入度为0，其余顶点的入度均为1的**有向图**
   24. 生成森林：有向图的生成森林是有若干棵互不相交的有向树组成的，包含了图中所有顶点

3. 存储方法：
   1. 邻接矩阵存储
      1. 简述：顶点集用一维数组存储，边集用n*n的二维数组存储，该二维数组即为邻接矩阵
      2. 性质：
         1. 无向图的邻接矩阵对称，有向图的邻接矩阵不一定对称
         2. 有向图的邻接矩阵行表示发射，列表示接受，顶点的出度为行中元素之和，入度为列中元素之和
      3. 结论：
         1. 时间复杂度：
            1. 确定两个顶点之间是否有边，O(1)
            2. 加入或删除一条边，O(1)
            3. 寻找一个顶点的所有邻接点，O(n)
            4. 存储所有边, O(n ^ 2)
         2. 缺点：删除或增加顶点需要新建邻接矩阵
   2. 邻接(链)表存储
      1. 简述：顶点以表头结点的形式存储在一维数组中，每个表头结点拉出一条由表结点组成的单链表，包含所有邻接顶点
      2. 结构：
         1. 表头结点：数据域data 和 指针域first，数据域包含顶点的数据信息，指针域指向第一个表结点
         2. 表结点：位置域adjvex, 信息域info 和 指针域next，位置域存放顶点位置(在数组中的下标等)，信息域中存放边的信息(权值等)，指针域指向下一个表结点
      3. 有向图的逆邻接表：链表中的顶点邻接到表头结点，邻接表是表头结点邻接到链表中的顶点
      4. 结论
         1. 时间复杂度：
            1. 确定边关系，需要遍历单链表，O(n)
            2. 加入或删除一条边，需要遍历单链表，O(n)
            3. 寻找一个顶点的所有邻接顶点，需要遍历单链表，O(n)
         2. 空间复杂度：
            1. 无向图： O(n + 2 * e)
            2. 有向图：O(n + e)
   3. 十字链表和邻接多重表
      1. 十字链表 可以看作是邻接矩阵的压缩存储
      2. 邻接多重表是 用表节点表示边，边上的两个顶点均指向该表节点
   4. 边表存储
      1. 简述：将顶点放在一个数组中，将边按顺序放在一个数组中，其中每个元素包含边的两个顶点、边的权值等信息
      2. 优点和缺点
         1. 优点：插入和删除边的时间复杂度为O(n), 遍历所有边只需要遍历一次边表
         2. 缺点：查找某个顶点的邻接点时需要遍历边表

4. **图的遍历**

   1. 简述：将非线性结构进行线性化的过程

   2. 方法分类

      1. DFS(深度优先搜索)

         1. 思想：

            ```markdown
            1. 选一个顶点v0作为源点开始搜索，访问v0的未被访问过的邻接点v1
            2. 从v1出发递归的按照1进行遍历
            3. 当遇到一个顶点没有邻接点或其邻接点都已经被访问时，退回到调用它的顶点vj
            4. 从vj出发递归的按照1进行遍历
            5. 重复上述过程，直到所有顶点都被访问
            ```

         2. 性能分析：

            1. 当存储结构为邻接矩阵时，需要遍历整个矩阵，时间复杂度为O(n^2)
            2. 当存储结构为邻接表时，需要遍历所有链表, 时间复杂度为O(e)

      2. BFS(广度优先搜索)

         1. 思想：

            ```markdown
            1. 选一个顶点v0作为源点开始搜索
            2. 访问v0所有未被访问的邻接点
            3. 按照2中访问的顺序，依次将这些顶点作为源点重复1
            4. 直到所有顶点都被访问
            ```

         2. 性能分析 -- 同深度优先搜索

   3. 应用

      1. 拓扑排序

         1. 术语

            1. AOV网(activity on vertex network)：用顶点表示活动的网
            2. 有向边的意义：表示各活动之间的先后关系
            3. 拓扑序列：一个线性序列，在这个序列中任何活动都不依赖于排在它后面的活动

         2. 思路

            ```markdown
            1. 计算所有顶点的入度
            2. 将所有入度为0的顶点放入队列
            3. 如果队列不为空, 将队头元素赋值给tmp，并将其出队
            4. 将tmp的邻接点的入度减一，如果减一之后入度变为0，则将其入队
            5. 转到3，循环执行，找到队列为空
            6. 如果队列为空，且所有顶点都已经被输出，则得出了一个拓扑序列；如果还有顶点未被输出，则认为存在回路
            ```

         3. 时间复杂度：计算入度的时间复杂度为O(n + e), 开始入度为0的顶点入对的时间复杂度是O(n), 顶点出队入队n次，入度减一操作e次，综上，时间复杂度为O(n + e)

      2. 关键路径

         1. 术语

            1. AOE网(activity on edges)：用边表示活动的网络
            2. 关键路径：最长的路径
            3. 关键活动：关键路径上的所有活动都是关键活动
      
         2. 常用表达式
      
            1. Ve[i]: 事件Vi的最早发生时间
            2. Vl[i]: 事件Vi的最迟发生时间
            3. e[k]: 活动ak(ak = <Vi, Vj>)的最早开始时间  e[k] = Ve[i]
            4. l[k]:  活动ak的最迟开始时间  l[k] = Vl[j] - dut(<Vi, Vj>)
      
         3. 思路

            ```markdown
            1. 从源点Vs出发，令Ve[s] = 0, 通过拓扑排序求出其余顶点的最早发生时间Ve[i]
            2. 从终点Vn出发，令Vl[n] = Ve[n], 通过逆拓扑排序求出其余顶点的最迟发生时间
            3. 根据各个顶点的Ve和Vl值，求出每条边的最早开始时间e[k]和最迟开始时间l[k]
            4. 如果某条边满足e[k] = l[k], 则这条边就是关键活动
            ```
      
      3. 最短路径
      
         1. **单源最短路**(常用Dijkstra算法)
      
            1. 思路：
      
            ```markdown
            图的顶点集V被划分了S和V/S，S中存储的是已经确定了最短路径的顶点；
            最开始时S中只含有源点vs, 每次确定一条最短路径，就将相应的顶点加入到S中，知道S = V
            1. 将vs放入S中，并初始化dist[]
            	如果i = s, dist[i] = 0; 如果vs, vi之间存在边, 则dist[i] = weight(s, i);
            	如果vs，vi之间没有边，则dist[i] = ∞
            2. 遍历dist数组, 选出满足条件 dist[j] = min{dist[i] | vi不属于S} 的顶点vj，并将vj加入S中
            3. 遍历dist数组, 令dist[i] = min{dist[i], dist[j] + weight(j, i)}
            4. 重复2, 3，直到S = V
            ```
      
            2. 时间复杂度为O(n ^ 2)
      
         2. **任意顶点对间最短路**
      
            1. 思路
      
               ```markdown
               1. 在顶点集中依次选择顶点，记作k
               2. 每次取出一个顶点，以该顶点为中转顶点，尝试对任意两顶点之间的距离进行更新
               dist[i][j] = min(dist[i][j], dist[i][k] + dist[i][k])
               ```

            2. 代码实例

               ```c++
               int d[v][v];
               int prev[v][v]; // prev[i][j]是从i到j的最短路径中j的前驱顶点
               int v; // 顶点数
               
               /*
               d[v][v]和prev[v][v]的初始化省略
               */
               
               for (int k = 0; k < v; ++k) 
               	for (int i = 0; i < v; ++i)
               		for (int j = 0; j < v; ++j)
               			if (d[i][k] + d[k][j] < d[i][j]) {
                               d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
                               prev[i][j] = k;
                           }
               ```
      
      4. 最小生成树
      
         1. prim算法
      
            1. 思路
      
               ```markdown
               1. 初始化边集E、点集V，选择一个顶点加入集合S中
               2. 从与该顶点相连的边中选出最短的那一条，将另一端的顶点加入S中
               3. 从所有与S中顶点相连的边中选出最短的一条，将另一端的顶点加入S中
               4. 重复上述操作，直到S = V
               ```
      
            2. 时间复杂度：O(n ^ 2)
      
         2. kruskal算法
      
            1. 思路
      
               ```markdown
               1. 将所有边按照权重递增排序
               2. 每次选出最小的一条边加入，如果形成了回路则跳过这一条边
               3. 直到加入的边数为n - 1
               ```
      
            2. 时间复杂度：时间复杂度主要由排序的时间复杂度决定



#### 七. 排序算法

1. 概念：

   1. 关键字项和关键值：关键字项是用来唯一标识一个数据元素的数据项，关键值是关键字项的值
   2. 排序的定义：将数据元素的任意序列，按关键字重新排序成有序序列
   3. 排序的稳定性：如果具有相同关键字的数据元素的相对位置没有发生改变，则称这种算法是稳定的；反之，则称这种算法是不稳定的

2. **简单排序**    时间复杂度基本都是O(n ^ 2)

   1. 插入排序

      1. 思想

         ```markdown
         假设前i个元素R[0]到R[i - 1]已经排好序
         1. 从后往前遍历查找R[i]在前i个元素中插入位置j R[j - 1].key <= R[j].key < R[j + 1].key (从后往前遍历可以保证稳定性)
         2. 找到后将R[j]到R[i - 1]均往后移动一位
         3. 将i插入到j位置上
         4. i++, 转到1
         ```

      2. 结论

         1. 空间复杂度：辅助空间为1，所以空间复杂度为O(1)
         2. 时间复杂度：平均时间复杂度为O(n ^ 2)
            1. 最好情况：序列已经是有序的，并且是我们所需要的顺序，时间复杂度为O(n)
            2. 最坏情况：序列已经是有序的，但正好与我们所需要的顺序相反，时间复杂度为O(n ^ 2)
         3. 稳定性和适用性：是稳定的  适用于数据量较小的情况
         
         

   2. 冒泡排序

      1. 思想

         ```markdown
         1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个。
         2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
         3. 针对所有的元素重复以上的步骤，除了最后一个。
         4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
         ps: 通过设置一个标识位来记录一趟过程中是否有交换元素，如果没有则说明已经有序
         ```

      2. 结论

         1. 空间复杂度：交换时需要附加空间，所以复杂度为O(1)
         2. 时间复杂度：平均复杂度为O(n ^ 2)
            1. 最好情况：序列从小到大有序，第一趟完成后就不需要在比较，时间复杂度为O(1)
            2. 最坏情况：序列从大到小有序，每一趟每次移动都得交换，时间复杂度为O(n ^ 2)
         3. 稳定性： 是稳定的

         

   3. 选择排序

      1. 思想

         ```markdown
         待排序序列为R[0]到R[n - 1]
         1. 令i = 0
         2. 在未排序的序列R[i]到R[n - 1]中选出关键值最小(大)的元素
         3. 如果该元素不是R[i]，则将其与R[i]交换; 否则，不交换
         4. 将i加一，转到2，直到i = n - 1为止
         ```

      2. 结论

         1. 空间复杂度：因为需要交换，所以空间复杂度为O(1)
         2. 时间复杂度：最好最坏情况下都是O(n ^ 2)
         3. 稳定性：不稳定

         

3. **高级排序**   时间复杂度基本都是O(n * log n)

   1. 希尔排序

      1. 思想

         ```markdown
         1. 选定一个步长gap(gap < n)
         2. 将距离为gap的倍数的元素分在一组(即 j - i = gap * k)
         3. 分别对每组元素进行插入排序
         4. 将gap减小，重复上述操作，直到gap为1为止 (gap为1时 就是插入排序)
         ```

      2. 结论

         1. 空间复杂度：进行插入排序时需要辅助空间，空间复杂度为O(1)
         2. 时间复杂度：gap序列取值合理时，时间复杂度可达到O(n ^ 1.5)
         3. 稳定性：不稳定

   2. 快速排序

      1. 思想

         ```markdown
         1. 从序列中选择一个元素(通常是随机选择)
         2. 以这个元素作为基准，将序列分作两部分，比基准小的在基准的左侧，比基准大的在基准的右侧
         3. 依次对左右两个序列进行上述操作，直到子序列长度为1或0
         ```

      2. 结论

         1. 空间复杂度：快排可以原地进行，只需考虑交换元素时的辅助空间，O(log n)
         2. 时间复杂度：
            1. 最坏情况：当基准选择不恰当时，复杂度可达到O(n ^ 2)
            2. 最好情况 / 平均情况： O(n log(n))

         3. 稳定性：不稳定

   3. 归并排序

      1. 思想

         ```markdown
         归并排序分为 分割和归并
         1. 将序列分为两个近乎等长的序列
         2. 对这两个序列分别进行归并排序
         3. 当两个子序列有序之后，对其进行归并(使用双指针加额外辅助空间进行归并)
         ```

      2. 结论

         1. 空间复杂度：归并时需要一个辅助数组，所以空间复杂度为O(n)
         2. 时间复杂度：最好最坏平均时间复杂度均为O(nlogn)
         3. 稳定性：是稳定的

   4. 锦标赛排序

      1. 思路

         ```markdown
         1. 将n个元素进行两两比较，记下优胜者
         2. 在上述优胜者中再两两比较，重复进行上述操作
         3. 一轮之后，选出来最大(小)的元素
         4. 将该元素设置为无穷小(无穷大)，重复上述操作
         ```

      2. 结论

         1. 空间复杂度：比较时需要记录优胜者，所以空间复杂度为O(n)
         2. 时间复杂度：每一轮时间复杂度为O(log n), 所以时间复杂度为O(n logn)
         3. 稳定性：不具有稳定性

   5. 堆排序

      1. 思路

         ```markdown
         1. 对序列进行建大(小)根堆
         2. 将根与堆中最后一个元素进行交换
         3. 对除最后一个元素以外的元素组成的堆进行调整，使其恢复成大(小)根堆
         4. 重复上述操作，直到序列中只剩一个元素，我们就得到了一个递增(减)序列
         ```

      2. 结论

         1. 空间复杂度：仅在交换时需要辅助空间，所以空间复杂度为O(1)
         2. 时间复杂度：O(n log n)
         3. 稳定性：不稳定

         

4. 非关键值比较排序

   1. 基数排序

      1. 思想

         ```markdown
         1. 将所有比较数值统一规定为相同的位数，位数不够的在前面补零
         2. 从低位向高位依次进行排序，按照当前位上的数将元素放入对应的桶中
         3. 排完最高位之后序列就是有序的
         ```

      2. 结论

         数组长度为n 基数为r 关键字位数为d

         1. 空间复杂度：需要桶来存储对应元素，所以空间复杂度为O(r * d)
         2. 时间复杂度：O(nd + r * d^2)
         3. 稳定性：是稳定的

5. 多关键字排序： 与基数排序思想类似

6. 算法比较

   | 排序方法 | 最好时间复杂度  | 平均时间复杂度  | 最坏时间复杂度  | 空间复杂度 | 稳定性 |
   | -------- | :-------------: | :-------------: | :-------------: | :--------: | :----: |
   | 插入排序 |      O(n)       |     O(n^2)      |     O(n^2)      |    O(1)    |  稳定  |
   | 冒泡排序 |      O(n)       |     O(n^2)      |     O(n^2)      |    O(1)    |  稳定  |
   | 选择排序 |     O(n^2)      |     O(n^2)      |     O(n^2)      |    O(1)    | 不稳定 |
   | 希尔排序 |   O(n ^ 1.5)    |   O(n ^ 1.5)    |   O(n ^ 1.5)    |    O(1)    | 不稳定 |
   | 快速排序 |    O(n logn)    |    O(n logn)    |     O(n^2)      |  O(logn)   | 不稳定 |
   | 归并排序 |    O(n logn)    |    O(n logn)    |    O(n logn)    |    O(n)    |  稳定  |
   | 堆排序   |    O(n logn)    |    O(n logn)    |    O(n logn)    |    O(1)    | 不稳定 |
   | 基数排序 | O(nd + r * d^2) | O(nd + r * d^2) | O(nd + r * d^2) |  O(r * d)  |  稳定  |



#### 八. 查找算法

1. 定义：查找(检索), 是指确定一个已经给出的数据是否出现在某个数据元素集合中

2. 概念：
   1. 键：数据元素中某项或组合项的值，可以用来标识一个数据元素。
   2. 主键和次键：主键是能唯一确定一个数据元素的键，次键是不能唯一确定一个数据元素的键
   3. 查找表：由具有同一类型(属性)的数据元素组成的集合
   4. 查找：在查找表中查找键值与待查元素值相等的过程
   5. **平均查找长度**(**ASL**)：查找过程中对键需要执行的平均比较长度，是衡量查找算法优劣的标准

3. 顺序查找：

   1. 简述：依次逐个比较是否相等

   2. 结论：

      1. 平均查找长度：第i个元素的比较次数为i，每个元素查找成功的机会均等，    

         所以平均查找长度为 (n + 1) / 2

      2. 时间复杂度：显然为O(n)

   3. 提高查找效率的方法：

      1. 每次成功查找都将被查找元素移动到表头
      2. 每次成功查找都将被查找元素前移一个位置
      3. 计算每个元素的频率，每次成功查找后，更新元素频率，并移动元素位置，使频率较大的元素在前

4. 折半查找：

   1. 简述：只适用于有序顺序表

   2. 步骤：

      ```markdown
      1. 将待查找值k与rec[mid]比较, mid = low + (high - low) / 2
      2. 如果相等, 则查找成功
      3. 如果k < rec[mid], 则在rec[low, mid - 1]中查找
      4. 如果k > rec[mid], 则在rec[mid + 1, high]中查找
      ```

   3. 结论

      1. 平均查找长度：把数组近似看作是一棵完全二叉树，

         那么平均查找长度 = 
         $$
         1 * 2^0 + 2 * 2^1 + ...+ h * 2^{h - 1}  =  {n + 1 \over n}log_2{(n + 1)}
         $$
         
      2. 时间复杂度：O(log n)
      
      3. 优缺点：
      
         1. 优点：效率高
         2. 缺点：需要预先排序，只适用于顺序结构

5. **哈希表(hash)**

   1. 简述：hash表是非关键字查找，可以实现随机存取；哈希表使用哈希函数来将关键字映射到地址
   2. 概念：哈希是指 将关键字映射到表中的位置来访问记录的过程
   3. 实现哈希函数的方法
      1. 直接定址法
         1. 简述：采用线性函数 hash(key) = a * key + b
         2. 优缺点：
            1. 优点：一对一映射，一般不会冲突
            2. 缺点：适用于关键字分布基本连续的情况，不连续的话会造成较大空间浪费

      2. 除留余数法：hash(key) = key & p, 记哈希表最大地址为m，则p为不大于m的最大质数
      3. 平方取中法：计算关键字的平方值，取中间几位数作为地址
      4. 随机数法： hash(key) = random(key)
      5. 截断法：选取关键字中区分性好的段作为地址
      6. 折叠法：将关键字从左往右分成位数相同的几部分(最后一部分可能短一些), 将这些部分的数据叠加起来
   4. 解决哈希冲突的方法
      1. 开放哈希：冲突元素不占据哈希表空间
         1. 链地址法：关键字的地址相同的元素存在同一个线性链表中
         2. 公共溢出区法：发生冲突的元素在溢出区依次顺序存放
      2. 封闭哈希：允许冲突元素方法哈希表空间中
         1. 线性探测法：从发生冲突的地址开始，依次探测下一个地址，直到找到空闲地址或者地址全满为止
            1. 缺点是存在“堆积"现象，增加了查找时间
         2. 平方探测法：与线性探测法类似，但增量为i ^ 2,
            1. 优点是部分解决了"堆积"现象，缺点是不能保证探测到哈希表所有位置
         3. (伪)随机探测法：每次冲突的下一个空位是随机选取的
   5. 哈希表元素删除：在删除元素的位置设置一个"墓碑标志"
   6. 性能分析：查找过程中关键字的比较次数取决于产生冲突的多少，即平均查找长度与n无关，**ASL(平均查找长度)是装填因子的函数**
      1. 影响产生冲突的因素
         1. 哈希函数是否均匀
         2. 解决冲突的方法是否合理
         3. 哈希表的装填因子，z = n / m, n为关键字个数，m为哈希表的表长

6. 线性索引

   1. 索引结构：由数据表和索引表组成
      1. 数据表用来存储数据元素信息
      2. 索引表中的元素叫索引项，索引项 = <关键字，指针>，指针指向数据表中包含该关键字的数据记录

   2. 分类
      1. 线性索引
         1. 简述：按照关键字进行排序，可用顺序查找或折半查找进行定位
         2. 优点：定长且有序，利用折半查找可以提高检索效率
         3. 缺点：数据过多时，索引文件可能过大导致内存中无法存储，因此检索时需要多次访问磁盘，导致效率降低
         4. 解决：建立多级索引

      2. 分块索引
         1. 简述：数据块之间按照每个块中的最大(最小)关键字有序，数据块内是降序(或升序), 索引表中存储的是每个块中的最大值(最小值)
         2. 分析：记块的长度为s，记录数为n, 则索引表的长度为n / s, 复杂度为O(n / s + s)

7. 树形索引

   1. 2-3树
      1. 定义：
         1. 每个节点的子树为2-3个(每个节点的关键字数 是 子树个数 - 1)
         2. 所有叶子节点在同一层出现，即高度是一致的

      2. 节点关系：
         1. 左孩子中的节点值小于父节点中第一个关键字的值
         2. 中间孩子中的节点值大于父节点中第一个关键字的值，且小于第二个关键字的值
         3. 右边孩子中的节点值大于父节点中第二个关键字的值

      3. 查找：按照大小关系进行查找即可
      4. 插入：
         1. 叶子节点中有空位置，直接插入
         2. 叶子节点已满，将叶子节点中的中间节点提升到父节点








考试复习：

 1. 各种定义

 2. 三大类型的数据结构  线性结构  树形结构  网状结构

 3. 性能

 4. 算法

    	1. 算法思想
        	2. 时间空间复杂度分析
        	3. 适用范围：最好情况 & 最坏情况








### 										数据结构实验报告

#### 1. 背包问题求解

 1. 问题描述与分析：

    1. 问题描述: 

       n件物品体积分别为w1, w2, w3, ...., wn 背包体积为T 

       问是否可以用若干件物品正好装满背包, 给出所有满足条件的解

    2. 问题分析:

       典型的 01背包 问题, 每件物品取或者不取, 优解为动态规划, 暴力解为回溯，但是此题要求给出所有满足条件的解，动态规划只能判断是否有解，但不能给出所有解，因此采用回溯法解决

 2. 算法思路

    ​	首先将物品按照体积排序，然后进行回溯，path记录当前的已经加入了背包中的元素，当sum等于t时说明背包恰好装满，找到了一个解；如果sum > t，则回溯到上一个状态；如果sum < t，则继续加入物品。

    ```c++
    void traceback(const vector<int>& w, const int& t, vector<int> path, int index, int sum);
    ```

 3. 输入输出

    1. 输入  每一行都是一个独立的测试用例  第一个数是背包体积T 后面一系列数是物品体积

       ```
       10 6 1 8 4 3 5 2
       20 6 1 8 4 3 5 2 13 11 9 17 7 6
       ```

    2. 输出  每一行都是一个解  用一个空行来分隔每个用例的输出

       ```
       1 2 3 4 
       1 4 5 
       2 3 5 
       2 8 
       
       1 2 4 5 8 
       3 4 5 8
       ```

 4. 算法评价

    ​	正常的回溯算法，通过剪枝提高了一下效率

#### 2. 农夫过河问题

	1. 问题描述与分析：
	
		1. 问题描述：一个农夫带着一只狼、一只羊和一棵白菜，身处河的南岸。他要把这些东西全部运到北岸。船只能容下农夫和一件物品，另外只有农夫才能撑船。如果农夫在场，则狼不能吃羊，羊不能吃白菜，否则狼会吃羊，羊会吃白菜，请求出农夫将所有的东西运过河的方案
		2. 问题分析：将每个状态当成一个节点，起始节点是农夫、狼、羊、白菜在南岸，终止节点是农夫、狼、羊、白菜在北岸，因此整个问题就是找到一条从起始节点到终止节点，且不经过不安全节点的路径。
	
	2. 算法思路：
	
	​	采用广度优先搜索，forbid中存储不安全的状态，used中存储已经经过的状态，move中存储的是农夫所能够采取的行动，status代表了当前的状态，ending是终止节点，path则是路径。
	
	​	从最开始的状态出发，调用bfs，每次将所有行动都实施一遍，判断到达的状态是否安全，安全则继续调用bfs，否则就跳过此次行动，实施下一个行动
	
	```c++
	void bfs(const unordered_set<int>& forbid, unordered_set<int> used, 
	const vector<int>& move, int status, const int& ending, vector<int> path)
	```

3. 输入输出

   1. 输入：无输入

   1. 输出：此处仅给出了一个解

      ```
      农夫在北岸 农夫在南岸 农夫在北岸 农夫在南岸 农夫在北岸 农夫在南岸 农夫在北岸 农夫在南岸
      狼在北岸   狼在北岸  狼在北岸   狼在南岸   狼在南岸   狼在南岸  狼在南岸   狼在南岸
      羊在北岸   羊在南岸  羊在南岸   羊在南岸   羊在北岸   羊在北岸  羊在北岸   羊在南岸
      白菜在北岸 白菜在北岸 白菜在北岸 白菜在北岸 白菜在北岸 白菜在南岸 白菜在南岸 白菜在南岸
      ```

4. 算法评价

​		将状态和状态转移用二进制数来表示，通过抽象使问题更易于解决。算法通过常用的bfs来找到一条路径，也可以使用dfs来寻找路径



#### 3. 八皇后问题

 1. 问题描述与分析

    	1. 问题描述：在8*8的棋盘上放8个棋子，要求（1）任意两个棋子不得放在同一行（2）任意两个棋子不得放在同一列上（3）任意棋子不得放在同一正斜线和反斜线上。
        	2. 分析：典型的回溯问题

 2. 算法思路

    ```markdown
    1. 在第一行中依次在第一列到最后一列放置棋子
    2. 对于每一行中的每一列，判断棋子放在该处是否会被攻击，
    3. 如果会被攻击，那么就跳过该列，判断下一列
    4. 如果不会，那么就先将棋子放置在该行该列，将行数加一，递归调用转到1，递归结束后再将棋子拿走(回溯)
    5. 若当前行数 = 最大行数 + 1， 说明已经找到了八皇后的一个解
    ```

    ​	首先对第一行调用回溯函数，在函数中依次判断棋子放在某一列是否符合要求，如果符合，则对下一行调用回溯函数，否则就跳到下一列继续判断

 3. 输入输出

    1. 输入

       ```
       8
       ```

    2. 输出

       <img src="C:\Users\29323\AppData\Roaming\Typora\typora-user-images\image-20230227111441372.png" alt="image-20230227111441372" style="zoom:50%;" /><img src="C:\Users\29323\AppData\Roaming\Typora\typora-user-images\image-20230227111536669.png" alt="image-20230227111536669" style="zoom:50%;" />

 4. 算法评价

    对算法进行了改进，可以通过输入n来解决n皇后问题。



#### 4. 约瑟夫环问题

	1. 问题描述与分析
	
		1. 问题描述：n个人围成一个圈，每个人持有一个密码，有一个报数上限m，第一个人从1开始报数，报到m的人出列，并将他的密码作为新的m，直到所有人都出列。求出列序列
		2. 问题分析：使用循环链表进行求解
	
	2. 算法思路
	
	​	首先按照顺序构造一个循环链表，以密码作为各个节点的值，遍历循环链表，设置一个cnt用来计数，当cnt = m时，就将当前节点删除并输出其编号，并将m设置为该节点的值，重置cnt，继续遍历，直到链表为空为止
	
	3. 输入输出
	
		1. 输入  第一行是人数和报数上限  第二行是每个人的密码
	
	    ```
	    7 20
	    3 1 7 2 4 8 4
	    ```
	
		2. 输出
	
	    ```
	    出列人编号序列如下: 
	    6 1 4 7 2 3 5 
	    ```
	
	4. 算法评价

​		循环链表问题进行求解，速度有待提高



#### 5. 教学计划编制问题

 1. 问题描述与分析

    	1. 问题描述：已知学期数，一学期学分上限，课程名称和课程学分，课程之间的先修关系，设计一个教学计划
        	2. 问题分析：存在先修关系，使用拓扑排序来解决，然后按照先修关系和学分上限对课程进行分配

 2. 算法思路

    1. 拓扑排序

       ```markdown
       1. 将入度为零的节点全部入队
       2. 当队列不为空时，依次将节点出队并输出
       3. 对于每个出队的节点，将它指向的节点的入度减一
       4. 检查此时是否有节点入度为零，有则全部入队
       5. 直到队列为空，此时输出的序列就是拓扑序列
       ```

    2. 课程分配

       ```markdown
       1. 依次对拓扑序列中的每个节点进行操作
       2. 记学期数cnt = 1, 如果当前节点的先修节点已分配到第id个学期，令cnt = id + 1
       3. 如果当前学期的学分加上该课程的学分后，仍未达到上限，那么就将该课程分配到第cnt个学期
       4. 否则，令cnt = cnt + 1, 转到3
       5. 直到所有课程都分配完毕
       ```

 3. 输入输出

    1. 输入 

       第一行为学期数，学分上限，课程数，第二行第三行为课程名称和课程学分，余下的是课程间的先修关系

       ```
       6 10 12
       C01 C02 C03 C04 C05 C06 C07 C08 C09 C10 C11 C12
       2 3 4 3 2 3 4 4 7 5 2 3
       1 4
       1 2
       1 3
       1 12
       9 12
       9 10
       9 11
       4 5
       2 3
       10 12
       11 6
       3 5 
       3 7
       3 8
       6 8
       5 7
       ```

    2. 输出

       ```
       第1个学期的课程如下：
           C01  2学分        C09  7学分        
       第1个学期的总学分为9
       
       第2个学期的课程如下：
           C02  3学分        C04  3学分        C11  2学分        
       第2个学期的总学分为8
       
       第3个学期的课程如下：
           C03  4学分        C10  5学分        
       第3个学期的总学分为9
       
       第4个学期的课程如下：
           C05  2学分        C06  3学分        C12  3学分        
       第4个学期的总学分为8
       
       第5个学期的课程如下：
           C07  4学分        C08  4学分        
       第5个学期的总学分为8
       
       第6个学期的课程如下：
       第6个学期的总学分为0
       ```

 4. 算法评价

​		仅解决了将课程尽量排布在前面的方案，未实现课程均匀分布的方案



#### 6. 二叉排序树的链表表示和数组表示

		1. 问题描述和分析
	
	 		1. 问题描述：分别用链表和数组的结构存储二叉排序树，并实现建树、中序遍历、计算ASL、查找元素和删除元素等操作
	 		2. 问题分析：分函数实现不同的操作即可
	
		2. 算法思路
	
	 		1. 存储结构
	
	      		1. 链表结构存储二叉排序树
	
	           ```c++
	           class TreeNode {
	           public:
	           	TreeNode* left;
	           	TreeNode* right;
	           	int val;
	           
	           	TreeNode(int v): val(v), left(nullptr), right(nullptr) { };
	           };
	           ```
	
	      2. 数组结构存储二叉排序树：直接用数组进行存储即可，通过下标计算来得到左右孩子
	
	         ```markdown
	         如果2 * i + 1 < n, 那么a[i]的左孩子是a[2 * i + 1],
	         如果2 * i + 2 < n, 那么a[i]的右孩子是a[2 * i + 2]
	         ```
	
	 		2. 建立二叉排序树：建树实际上是不断将所有元素插入，因此只需要实现插入操作即可实现建树
	
	      		1. 插入操作思路
	
	           ```markdown
	           1. 如果树为空，就将此节点作为根节点新建一棵树
	           2. 如果此节点的值比根节点的值要小，就将它递归插入到左子树中
	           3. 如果此节点的值比根节点的值要大，就将它递归插入到右子树中
	           4. 如果此节点的值和根节点相等，则return
	           ```
	
	 		3. 中序遍历：递归调用即可
	
	      ```c++
	      void inorder(TreeNode* root) {
	      	if (root == nullptr) return ;
	      	
	      	inorder(root->left);
	      	visit(root);
	      	inorder(root->right);
	      }
	      ```
	
	 		4. 计算ASL(平均查找长度) 
	
	      ​	使用层序遍历，计算出每一层的节点数. ASL = 每一层的层数 * 节点数 之和    /   节点数之和
	
	 		5. 查找元素
	
	      ```markdown
	      1. 如果和根节点值相同，则找到
	      2. 如果比根节点的值要小，递归在左子树中查找
	      3. 如果比根节点的值要大，递归在右子树中查找
	      4. 当到达了叶子节点后仍未查找成功，说明此元素不存在
	      ```
	
	 		6. 删除元素
	
	      ```markdown
	      1. 先找到要删除的节点cur
	      2. 当 cur 左子树不为空 右子树为空时 直接将左子树接上去即可
	      3. 当左子树为空 右子树不为空时 直接将右子树接上去
	      4. 当左右子树均为空时 删除cur即可
	      5. 当左右子树均不为空时 
	      	方法一 将左子树 作为右子树的最左侧的节点的左孩子
	      	方法二 用左子树中最大元素 或 右子树中最小元素 来代替该节点
	      ```
	
		3. 输入输出
	
	 		1. 输入  第一行是输入的元素  第二行是要删除的元素
	
	      ```markdown
	      32 5 8 1 6 53 64 75 2 74 65 2 46 234 543 42 65 54 7 534 46
	      52 2 767 534 534 47
	      ```
	
	 		2. 输出
	
	      ```markdown
	      中序遍历序列如下：
	      1 2 5 6 7 8 32 42 46 53 54 64 65 74 75 234 534 543 
	      
	      树形如下：
	      32
	      ├── 5
	      |   ├── 1
	      |   |   ├── (null)
	      |   |   └── 2
	      |   └── 8
	      |      ├── 6
	      |      |   ├── (null)
	      |      |   └── 7
	      |      └── (null)
	      └── 53
	         ├── 46
	         |   ├── 42
	         |   └── (null)
	         └── 64
	            ├── 54
	            └── 75
	               ├── 74
	               |   ├── 65
	               |   └── (null)
	               └── 234
	                  ├── (null)
	                  └── 543
	                     ├── 534
	                     └── (null)


​          
          查找成功的平均查找长度为 71/18
          
          未找到节点值为52的节点
          删除2后,中序遍历结果:
          1 5 6 7 8 32 42 46 53 54 64 65 74 75 234 534 543 
          未找到节点值为767的节点
          删除534后,中序遍历结果:
          1 5 6 7 8 32 42 46 53 54 64 65 74 75 234 543 
          未找到节点值为534的节点
          未找到节点值为47的节点
          ```
    
    	4. 算法评价

​			主要突出点在于表示二叉树的方法较为简便


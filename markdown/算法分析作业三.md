#### 一. 算法分析

![](/home/dawn/qqDocuments/扫描件_P 1134-14-4 P 1174-1_1.jpg)

![](/home/dawn/qqDocuments/扫描件_P 1134-14-4 P 1174-1_2.jpg)

![](/home/dawn/qqDocuments/扫描件_P 1134-14-4 P 1174-1_3.jpg)

#### 二.算法实现

1. 4-10：区间覆盖问题

    1. 代码实现

        ```c++
        # include <iostream>
        # include <vector>
        # include <string>
        # include <fstream>
        # include <algorithm>
        # include <unistd.h>
        using namespace std;
        
        /*
        每次都以最小的数字为区间的左端点，跳过那些被覆盖的点
        */
        
        int main() {
            string path = get_current_dir_name();
            string inName = "/cpp/course/algorithm_analyse/4_10_input.txt";
            string outName = "/cpp/course/algorithm_analyse/4_10_ouput.txt";
        
            ifstream in;
            ofstream out;
            in.open(path + inName, ios::in);
            out.open(path + outName, ios::out);
        
            int n, k;
            in >> n >> k;
            vector<int> arr(n);
            for (int i = 0; i < n; ++i) {
                in >> arr[i];
            }
            sort(arr.begin(), arr.end());
        
            int cnt = 1;
            int begin = arr[0];
            for (int i = 1; i < n; ++i) {
                if (arr[i] <= begin + k) continue;
                else {
                    begin = arr[i];
                    ++cnt;
                }
            }
        
            out << cnt;
        
            return 0;
        }
        ```

    2. 输入输出

        1. 输入: 每两行为一组输入  第一行为 点的个数和区间长度 第二行为点的坐标

            ```markdown
            7 3
            1 2 3 4 5 -2 6
            10 4
            132 6 4 63 41 74 5 63 -14 65 
            5 1
            1 2 3 4 5 
            8 2 
            200 5 42 6 412 625 53 4 
            ```

        2. 输出: 每一行为一组输出  代表区间数

            ```markdown
            3
            6
            3
            6
            1
            ```

            

2. 4-14：多元Huffman编码问题

    1. 代码实现

        ```c++
        # include <iostream>
        # include <fstream>
        # include <vector>
        # include <string>
        # include <unistd.h>
        # include <algorithm>
        # include <queue>
        using namespace std;
        
        /*
        最大花费是 每次取出最大的两堆合并
        最小花费是 每次取出最小的k堆合并
        */
        
        int main() {
            string path = get_current_dir_name();
            string inName = "/cpp/course/algorithm_analyse/4_14_input.txt";
            string outName = "/cpp/course/algorithm_analyse/4_14_ouput.txt";
        
            ifstream in;
            ofstream out;
            in.open(path + inName, ios::in);
            out.open(path + outName, ios::out);
        
            int n, k;
            in >> n >> k;
            // priority_queue默认比较函数为less 是大顶堆
            // 可以自定义为greater 小顶堆
            priority_queue<int, vector<int>, greater<int>> pri_min;
            priority_queue<int> pri_max;
            for (int i = 0; i < n; ++i) {
                int tmp;
                in >> tmp;
                pri_min.push(tmp);
                pri_max.push(tmp);
            }
            
            int max_sum = 0, min_sum = 0;
            while (pri_max.size() > 1) {
                int sum = 0;
                
                for (int i = 0; i < 2; ++i) {
                    sum += pri_max.top();
                    pri_max.pop();
                }
                pri_max.push(sum);
        
                max_sum += sum;
            }
            while (pri_min.size() > 1) {
                int sum = 0;
                for (int i = 0; i < k; ++i) {
                    if (!pri_min.empty()) {
                        sum += pri_min.top();
                        pri_min.pop();
                    }
                }
                pri_min.push(sum);
        
                min_sum += sum;
            }
        
            out << max_sum << " " << min_sum;
        
            return 0;
        }
        ```

    2. 输入输出

        1. 输入: 每两行为一组输入  第一行为石子堆数，每次最多可以合并的堆数  第二行为每一堆的石子数(后六组数据均为**随机数生成**，因此石子数存在重复)

            ```
            7 3
            45 13 12 16 9 5 22
            14 5
            7 9 3 8 6 6 3 5 5 8 11 6 9 2 
            18 3
            2 7 4 5 6 6 3 6 6 3 5 6 5 6 4 5 4 5 
            15 4
            8 8 6 7 5 7 8 7 3 3 2 8 5 4 9 
            18 6
            2 9 11 6 10 6 9 11 8 5 3 7 3 10 7 10 10 7 
            19 6
            9 13 2 12 10 7 8 8 9 4 2 10 11 6 11 10 4 10 3 
            17 6
            9 3 2 8 13 11 6 2 11 5 2 7 8 2 7 9 6 
            ```

        2. 输出：每行为一组输出  第一个是最大费用 第二个是最小费用

            ```
            593 199
            787 194
            943 264
            845 192
            1512 268
            1814 285
            1264 238
            ```

            
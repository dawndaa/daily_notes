# include <iostream>
# include <vector>
using namespace std;

/*
从1到2n开始顺序放置每个数，对于当前的数k，它的放置方式有两种
1. 放在第一行最左边的空位上
2. 放在第二行最左边的空位上
第二种操作只有在第一行的数比第二行的数多的情况下才能实行
这样的情形可以很好的和序列出入栈对应起来，
将1看成是入栈操作  2看成是出栈操作 只有在栈不为空的情况下才可以进行出栈操作
这样 这个问题就转化为了 求合法的出栈序列个数的问题
我们将 +1 记为入栈，将 -1 记为出栈，那么所有的序列个数为 C(2n, n)
对于每一个不合法的序列，它必定有一个前缀和是小于0的  否则他就是一个合法的序列了
将这个前缀和中每个元素取反，那么就会得到n + 1个 +1 和n - 1个 -1，所有不合法的序列个数就是 C(2n, n + 1)
所有最后的结果就是 C(2n, n) - C(2n, n + 1)
*/

int main() {
    int n;
    cin >> n;
    vector<long long> ctl(n + 1);
    
    ctl[0] = 1;
    for (int i = 1; i <= n; ++i) {
        ctl[i] = (4 * i - 2) * ctl[i - 1] / (i + 1);
    }

    cout << ctl[n] << endl;

    return 0;
}